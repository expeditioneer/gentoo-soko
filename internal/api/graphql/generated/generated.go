// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"github.com/expeditioneer/gentoo-soko/internal/models"
	"strconv"
	"sync"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Application struct {
		LastCommit func(childComplexity int) int
		LastUpdate func(childComplexity int) int
		Version    func(childComplexity int) int
	}

	Bug struct {
		Assignee  func(childComplexity int) int
		Component func(childComplexity int) int
		Id        func(childComplexity int) int
		Product   func(childComplexity int) int
		Status    func(childComplexity int) int
		Summary   func(childComplexity int) int
	}

	Category struct {
		Description func(childComplexity int) int
		Name        func(childComplexity int) int
		Packages    func(childComplexity int) int
	}

	ChangedFile struct {
		ChangeType func(childComplexity int) int
		Path       func(childComplexity int) int
	}

	ChangedFiles struct {
		Added    func(childComplexity int) int
		Deleted  func(childComplexity int) int
		Modified func(childComplexity int) int
	}

	Commit struct {
		AuthorDate       func(childComplexity int) int
		AuthorEmail      func(childComplexity int) int
		AuthorName       func(childComplexity int) int
		ChangedFiles     func(childComplexity int) int
		ChangedPackages  func(childComplexity int) int
		ChangedVersions  func(childComplexity int) int
		CommitterDate    func(childComplexity int) int
		CommitterEmail   func(childComplexity int) int
		CommitterName    func(childComplexity int) int
		Id               func(childComplexity int) int
		KeywordChanges   func(childComplexity int) int
		Message          func(childComplexity int) int
		PrecedingCommits func(childComplexity int) int
	}

	GitHubPullRequestFileNode struct {
		Additions func(childComplexity int) int
		Deletions func(childComplexity int) int
		Path      func(childComplexity int) int
	}

	GitHubPullRequestLabelNode struct {
		Color func(childComplexity int) int
		Name  func(childComplexity int) int
	}

	GithubPullRequest struct {
		Author      func(childComplexity int) int
		CiState     func(childComplexity int) int
		CiStateLink func(childComplexity int) int
		Closed      func(childComplexity int) int
		Comments    func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		Files       func(childComplexity int) int
		Id          func(childComplexity int) int
		Labels      func(childComplexity int) int
		Title       func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		Url         func(childComplexity int) int
	}

	KeywordChange struct {
		Added      func(childComplexity int) int
		All        func(childComplexity int) int
		Commit     func(childComplexity int) int
		CommitId   func(childComplexity int) int
		Id         func(childComplexity int) int
		Package    func(childComplexity int) int
		PackageId  func(childComplexity int) int
		Stabilized func(childComplexity int) int
		Version    func(childComplexity int) int
		VersionId  func(childComplexity int) int
	}

	Maintainer struct {
		Email    func(childComplexity int) int
		Name     func(childComplexity int) int
		Restrict func(childComplexity int) int
		Type     func(childComplexity int) int
	}

	Mask struct {
		Author      func(childComplexity int) int
		AuthorEmail func(childComplexity int) int
		Date        func(childComplexity int) int
		Reason      func(childComplexity int) int
		Versions    func(childComplexity int) int
	}

	OutdatedPackage struct {
		Atom          func(childComplexity int) int
		GentooVersion func(childComplexity int) int
		NewestVersion func(childComplexity int) int
	}

	Package struct {
		Atom                func(childComplexity int) int
		Bugs                func(childComplexity int) int
		Category            func(childComplexity int) int
		Commits             func(childComplexity int) int
		Longdescription     func(childComplexity int) int
		Maintainers         func(childComplexity int) int
		Name                func(childComplexity int) int
		Outdated            func(childComplexity int) int
		PkgCheckResults     func(childComplexity int) int
		PrecedingCommits    func(childComplexity int) int
		PullRequests        func(childComplexity int) int
		ReverseDependencies func(childComplexity int) int
		Versions            func(childComplexity int) int
	}

	PkgCheckResult struct {
		Atom     func(childComplexity int) int
		CPV      func(childComplexity int) int
		Category func(childComplexity int) int
		Class    func(childComplexity int) int
		Message  func(childComplexity int) int
		Package  func(childComplexity int) int
		Version  func(childComplexity int) int
	}

	Query struct {
		AddedPackages      func(childComplexity int, limit *int) int
		Application        func(childComplexity int) int
		Categories         func(childComplexity int, name *string, description *string) int
		Category           func(childComplexity int, name *string, description *string) int
		Commit             func(childComplexity int, id *string, precedingCommits *int, authorName *string, authorEmail *string, authorDate *time.Time, committerName *string, committerEmail *string, committerDate *time.Time, message *string) int
		Commits            func(childComplexity int, id *string, precedingCommits *int, authorName *string, authorEmail *string, authorDate *time.Time, committerName *string, committerEmail *string, committerDate *time.Time, message *string) int
		KeywordedVersions  func(childComplexity int, limit *int, arch *string) int
		LastCommitTime     func(childComplexity int) int
		Mask               func(childComplexity int, versions *string, author *string, authorEmail *string, date *time.Time, reason *string) int
		Masks              func(childComplexity int, versions *string, author *string, authorEmail *string, date *time.Time, reason *string) int
		OutdatedPackage    func(childComplexity int, atom *string, gentooVersion *string, newestVersion *string) int
		OutdatedPackages   func(childComplexity int, atom *string, gentooVersion *string, newestVersion *string) int
		Package            func(childComplexity int, atom *string, category *string, name *string, longdescription *string, precedingCommits *int) int
		PackageSearch      func(childComplexity int, searchTerm *string, resultSize *int) int
		Packages           func(childComplexity int, atom *string, category *string, name *string, longdescription *string, precedingCommits *int) int
		PkgCheckResult     func(childComplexity int, atom *string, category *string, packageArg *string, version *string, cpv *string, class *string, message *string) int
		PkgCheckResults    func(childComplexity int, atom *string, category *string, packageArg *string, version *string, cpv *string, class *string, message *string) int
		StabilizedVersions func(childComplexity int, limit *int, arch *string) int
		UpdatedVersions    func(childComplexity int, limit *int) int
		Useflag            func(childComplexity int, id *string, name *string, scope *string, description *string, useExpand *string, packageArg *string) int
		Useflags           func(childComplexity int, id *string, name *string, scope *string, description *string, useExpand *string, packageArg *string) int
		Version            func(childComplexity int, id *string, category *string, packageArg *string, atom *string, version *string, slot *string, subslot *string, eapi *string, keywords *string, useflags *string, restricts *string, properties *string, homepage *string, license *string, description *string) int
		Versions           func(childComplexity int, id *string, category *string, packageArg *string, atom *string, version *string, slot *string, subslot *string, eapi *string, keywords *string, useflags *string, restricts *string, properties *string, homepage *string, license *string, description *string) int
	}

	ReverseDependency struct {
		Atom                     func(childComplexity int) int
		Condition                func(childComplexity int) int
		Id                       func(childComplexity int) int
		ReverseDependencyAtom    func(childComplexity int) int
		ReverseDependencyVersion func(childComplexity int) int
		Type                     func(childComplexity int) int
	}

	Useflag struct {
		Description func(childComplexity int) int
		Id          func(childComplexity int) int
		Name        func(childComplexity int) int
		Package     func(childComplexity int) int
		Scope       func(childComplexity int) int
		UseExpand   func(childComplexity int) int
	}

	Version struct {
		Atom            func(childComplexity int) int
		Category        func(childComplexity int) int
		Commits         func(childComplexity int) int
		Dependencies    func(childComplexity int) int
		Description     func(childComplexity int) int
		EAPI            func(childComplexity int) int
		Homepage        func(childComplexity int) int
		Id              func(childComplexity int) int
		Keywords        func(childComplexity int) int
		License         func(childComplexity int) int
		Masks           func(childComplexity int) int
		Package         func(childComplexity int) int
		PkgCheckResults func(childComplexity int) int
		Properties      func(childComplexity int) int
		Restricts       func(childComplexity int) int
		Slot            func(childComplexity int) int
		Subslot         func(childComplexity int) int
		Useflags        func(childComplexity int) int
		Version         func(childComplexity int) int
	}
}

type QueryResolver interface {
	Category(ctx context.Context, name *string, description *string) (*models.Category, error)
	Categories(ctx context.Context, name *string, description *string) ([]*models.Category, error)
	Commit(ctx context.Context, id *string, precedingCommits *int, authorName *string, authorEmail *string, authorDate *time.Time, committerName *string, committerEmail *string, committerDate *time.Time, message *string) (*models.Commit, error)
	Commits(ctx context.Context, id *string, precedingCommits *int, authorName *string, authorEmail *string, authorDate *time.Time, committerName *string, committerEmail *string, committerDate *time.Time, message *string) ([]*models.Commit, error)
	Mask(ctx context.Context, versions *string, author *string, authorEmail *string, date *time.Time, reason *string) (*models.Mask, error)
	Masks(ctx context.Context, versions *string, author *string, authorEmail *string, date *time.Time, reason *string) ([]*models.Mask, error)
	OutdatedPackage(ctx context.Context, atom *string, gentooVersion *string, newestVersion *string) (*models.OutdatedPackages, error)
	OutdatedPackages(ctx context.Context, atom *string, gentooVersion *string, newestVersion *string) ([]*models.OutdatedPackages, error)
	PkgCheckResult(ctx context.Context, atom *string, category *string, packageArg *string, version *string, cpv *string, class *string, message *string) (*models.PkgCheckResult, error)
	PkgCheckResults(ctx context.Context, atom *string, category *string, packageArg *string, version *string, cpv *string, class *string, message *string) ([]*models.PkgCheckResult, error)
	Package(ctx context.Context, atom *string, category *string, name *string, longdescription *string, precedingCommits *int) (*models.Package, error)
	Packages(ctx context.Context, atom *string, category *string, name *string, longdescription *string, precedingCommits *int) ([]*models.Package, error)
	PackageSearch(ctx context.Context, searchTerm *string, resultSize *int) ([]*models.Package, error)
	Useflag(ctx context.Context, id *string, name *string, scope *string, description *string, useExpand *string, packageArg *string) (*models.Useflag, error)
	Useflags(ctx context.Context, id *string, name *string, scope *string, description *string, useExpand *string, packageArg *string) ([]*models.Useflag, error)
	Version(ctx context.Context, id *string, category *string, packageArg *string, atom *string, version *string, slot *string, subslot *string, eapi *string, keywords *string, useflags *string, restricts *string, properties *string, homepage *string, license *string, description *string) (*models.Version, error)
	Versions(ctx context.Context, id *string, category *string, packageArg *string, atom *string, version *string, slot *string, subslot *string, eapi *string, keywords *string, useflags *string, restricts *string, properties *string, homepage *string, license *string, description *string) ([]*models.Version, error)
	Application(ctx context.Context) (*models.Application, error)
	LastCommitTime(ctx context.Context) (*time.Time, error)
	AddedPackages(ctx context.Context, limit *int) ([]*models.Package, error)
	UpdatedVersions(ctx context.Context, limit *int) ([]*models.Version, error)
	StabilizedVersions(ctx context.Context, limit *int, arch *string) ([]*models.Version, error)
	KeywordedVersions(ctx context.Context, limit *int, arch *string) ([]*models.Version, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Application.LastCommit":
		if e.complexity.Application.LastCommit == nil {
			break
		}

		return e.complexity.Application.LastCommit(childComplexity), true

	case "Application.LastUpdate":
		if e.complexity.Application.LastUpdate == nil {
			break
		}

		return e.complexity.Application.LastUpdate(childComplexity), true

	case "Application.Version":
		if e.complexity.Application.Version == nil {
			break
		}

		return e.complexity.Application.Version(childComplexity), true

	case "Bug.Assignee":
		if e.complexity.Bug.Assignee == nil {
			break
		}

		return e.complexity.Bug.Assignee(childComplexity), true

	case "Bug.Component":
		if e.complexity.Bug.Component == nil {
			break
		}

		return e.complexity.Bug.Component(childComplexity), true

	case "Bug.Id":
		if e.complexity.Bug.Id == nil {
			break
		}

		return e.complexity.Bug.Id(childComplexity), true

	case "Bug.Product":
		if e.complexity.Bug.Product == nil {
			break
		}

		return e.complexity.Bug.Product(childComplexity), true

	case "Bug.Status":
		if e.complexity.Bug.Status == nil {
			break
		}

		return e.complexity.Bug.Status(childComplexity), true

	case "Bug.Summary":
		if e.complexity.Bug.Summary == nil {
			break
		}

		return e.complexity.Bug.Summary(childComplexity), true

	case "Category.Description":
		if e.complexity.Category.Description == nil {
			break
		}

		return e.complexity.Category.Description(childComplexity), true

	case "Category.Name":
		if e.complexity.Category.Name == nil {
			break
		}

		return e.complexity.Category.Name(childComplexity), true

	case "Category.Packages":
		if e.complexity.Category.Packages == nil {
			break
		}

		return e.complexity.Category.Packages(childComplexity), true

	case "ChangedFile.ChangeType":
		if e.complexity.ChangedFile.ChangeType == nil {
			break
		}

		return e.complexity.ChangedFile.ChangeType(childComplexity), true

	case "ChangedFile.Path":
		if e.complexity.ChangedFile.Path == nil {
			break
		}

		return e.complexity.ChangedFile.Path(childComplexity), true

	case "ChangedFiles.Added":
		if e.complexity.ChangedFiles.Added == nil {
			break
		}

		return e.complexity.ChangedFiles.Added(childComplexity), true

	case "ChangedFiles.Deleted":
		if e.complexity.ChangedFiles.Deleted == nil {
			break
		}

		return e.complexity.ChangedFiles.Deleted(childComplexity), true

	case "ChangedFiles.Modified":
		if e.complexity.ChangedFiles.Modified == nil {
			break
		}

		return e.complexity.ChangedFiles.Modified(childComplexity), true

	case "Commit.AuthorDate":
		if e.complexity.Commit.AuthorDate == nil {
			break
		}

		return e.complexity.Commit.AuthorDate(childComplexity), true

	case "Commit.AuthorEmail":
		if e.complexity.Commit.AuthorEmail == nil {
			break
		}

		return e.complexity.Commit.AuthorEmail(childComplexity), true

	case "Commit.AuthorName":
		if e.complexity.Commit.AuthorName == nil {
			break
		}

		return e.complexity.Commit.AuthorName(childComplexity), true

	case "Commit.ChangedFiles":
		if e.complexity.Commit.ChangedFiles == nil {
			break
		}

		return e.complexity.Commit.ChangedFiles(childComplexity), true

	case "Commit.ChangedPackages":
		if e.complexity.Commit.ChangedPackages == nil {
			break
		}

		return e.complexity.Commit.ChangedPackages(childComplexity), true

	case "Commit.ChangedVersions":
		if e.complexity.Commit.ChangedVersions == nil {
			break
		}

		return e.complexity.Commit.ChangedVersions(childComplexity), true

	case "Commit.CommitterDate":
		if e.complexity.Commit.CommitterDate == nil {
			break
		}

		return e.complexity.Commit.CommitterDate(childComplexity), true

	case "Commit.CommitterEmail":
		if e.complexity.Commit.CommitterEmail == nil {
			break
		}

		return e.complexity.Commit.CommitterEmail(childComplexity), true

	case "Commit.CommitterName":
		if e.complexity.Commit.CommitterName == nil {
			break
		}

		return e.complexity.Commit.CommitterName(childComplexity), true

	case "Commit.Id":
		if e.complexity.Commit.Id == nil {
			break
		}

		return e.complexity.Commit.Id(childComplexity), true

	case "Commit.KeywordChanges":
		if e.complexity.Commit.KeywordChanges == nil {
			break
		}

		return e.complexity.Commit.KeywordChanges(childComplexity), true

	case "Commit.Message":
		if e.complexity.Commit.Message == nil {
			break
		}

		return e.complexity.Commit.Message(childComplexity), true

	case "Commit.PrecedingCommits":
		if e.complexity.Commit.PrecedingCommits == nil {
			break
		}

		return e.complexity.Commit.PrecedingCommits(childComplexity), true

	case "GitHubPullRequestFileNode.Additions":
		if e.complexity.GitHubPullRequestFileNode.Additions == nil {
			break
		}

		return e.complexity.GitHubPullRequestFileNode.Additions(childComplexity), true

	case "GitHubPullRequestFileNode.Deletions":
		if e.complexity.GitHubPullRequestFileNode.Deletions == nil {
			break
		}

		return e.complexity.GitHubPullRequestFileNode.Deletions(childComplexity), true

	case "GitHubPullRequestFileNode.Path":
		if e.complexity.GitHubPullRequestFileNode.Path == nil {
			break
		}

		return e.complexity.GitHubPullRequestFileNode.Path(childComplexity), true

	case "GitHubPullRequestLabelNode.Color":
		if e.complexity.GitHubPullRequestLabelNode.Color == nil {
			break
		}

		return e.complexity.GitHubPullRequestLabelNode.Color(childComplexity), true

	case "GitHubPullRequestLabelNode.Name":
		if e.complexity.GitHubPullRequestLabelNode.Name == nil {
			break
		}

		return e.complexity.GitHubPullRequestLabelNode.Name(childComplexity), true

	case "GithubPullRequest.Author":
		if e.complexity.GithubPullRequest.Author == nil {
			break
		}

		return e.complexity.GithubPullRequest.Author(childComplexity), true

	case "GithubPullRequest.CiState":
		if e.complexity.GithubPullRequest.CiState == nil {
			break
		}

		return e.complexity.GithubPullRequest.CiState(childComplexity), true

	case "GithubPullRequest.CiStateLink":
		if e.complexity.GithubPullRequest.CiStateLink == nil {
			break
		}

		return e.complexity.GithubPullRequest.CiStateLink(childComplexity), true

	case "GithubPullRequest.Closed":
		if e.complexity.GithubPullRequest.Closed == nil {
			break
		}

		return e.complexity.GithubPullRequest.Closed(childComplexity), true

	case "GithubPullRequest.Comments":
		if e.complexity.GithubPullRequest.Comments == nil {
			break
		}

		return e.complexity.GithubPullRequest.Comments(childComplexity), true

	case "GithubPullRequest.CreatedAt":
		if e.complexity.GithubPullRequest.CreatedAt == nil {
			break
		}

		return e.complexity.GithubPullRequest.CreatedAt(childComplexity), true

	case "GithubPullRequest.Files":
		if e.complexity.GithubPullRequest.Files == nil {
			break
		}

		return e.complexity.GithubPullRequest.Files(childComplexity), true

	case "GithubPullRequest.Id":
		if e.complexity.GithubPullRequest.Id == nil {
			break
		}

		return e.complexity.GithubPullRequest.Id(childComplexity), true

	case "GithubPullRequest.Labels":
		if e.complexity.GithubPullRequest.Labels == nil {
			break
		}

		return e.complexity.GithubPullRequest.Labels(childComplexity), true

	case "GithubPullRequest.Title":
		if e.complexity.GithubPullRequest.Title == nil {
			break
		}

		return e.complexity.GithubPullRequest.Title(childComplexity), true

	case "GithubPullRequest.UpdatedAt":
		if e.complexity.GithubPullRequest.UpdatedAt == nil {
			break
		}

		return e.complexity.GithubPullRequest.UpdatedAt(childComplexity), true

	case "GithubPullRequest.Url":
		if e.complexity.GithubPullRequest.Url == nil {
			break
		}

		return e.complexity.GithubPullRequest.Url(childComplexity), true

	case "KeywordChange.Added":
		if e.complexity.KeywordChange.Added == nil {
			break
		}

		return e.complexity.KeywordChange.Added(childComplexity), true

	case "KeywordChange.All":
		if e.complexity.KeywordChange.All == nil {
			break
		}

		return e.complexity.KeywordChange.All(childComplexity), true

	case "KeywordChange.Commit":
		if e.complexity.KeywordChange.Commit == nil {
			break
		}

		return e.complexity.KeywordChange.Commit(childComplexity), true

	case "KeywordChange.CommitId":
		if e.complexity.KeywordChange.CommitId == nil {
			break
		}

		return e.complexity.KeywordChange.CommitId(childComplexity), true

	case "KeywordChange.Id":
		if e.complexity.KeywordChange.Id == nil {
			break
		}

		return e.complexity.KeywordChange.Id(childComplexity), true

	case "KeywordChange.Package":
		if e.complexity.KeywordChange.Package == nil {
			break
		}

		return e.complexity.KeywordChange.Package(childComplexity), true

	case "KeywordChange.PackageId":
		if e.complexity.KeywordChange.PackageId == nil {
			break
		}

		return e.complexity.KeywordChange.PackageId(childComplexity), true

	case "KeywordChange.Stabilized":
		if e.complexity.KeywordChange.Stabilized == nil {
			break
		}

		return e.complexity.KeywordChange.Stabilized(childComplexity), true

	case "KeywordChange.Version":
		if e.complexity.KeywordChange.Version == nil {
			break
		}

		return e.complexity.KeywordChange.Version(childComplexity), true

	case "KeywordChange.VersionId":
		if e.complexity.KeywordChange.VersionId == nil {
			break
		}

		return e.complexity.KeywordChange.VersionId(childComplexity), true

	case "Maintainer.Email":
		if e.complexity.Maintainer.Email == nil {
			break
		}

		return e.complexity.Maintainer.Email(childComplexity), true

	case "Maintainer.Name":
		if e.complexity.Maintainer.Name == nil {
			break
		}

		return e.complexity.Maintainer.Name(childComplexity), true

	case "Maintainer.Restrict":
		if e.complexity.Maintainer.Restrict == nil {
			break
		}

		return e.complexity.Maintainer.Restrict(childComplexity), true

	case "Maintainer.Type":
		if e.complexity.Maintainer.Type == nil {
			break
		}

		return e.complexity.Maintainer.Type(childComplexity), true

	case "Mask.Author":
		if e.complexity.Mask.Author == nil {
			break
		}

		return e.complexity.Mask.Author(childComplexity), true

	case "Mask.AuthorEmail":
		if e.complexity.Mask.AuthorEmail == nil {
			break
		}

		return e.complexity.Mask.AuthorEmail(childComplexity), true

	case "Mask.Date":
		if e.complexity.Mask.Date == nil {
			break
		}

		return e.complexity.Mask.Date(childComplexity), true

	case "Mask.Reason":
		if e.complexity.Mask.Reason == nil {
			break
		}

		return e.complexity.Mask.Reason(childComplexity), true

	case "Mask.Versions":
		if e.complexity.Mask.Versions == nil {
			break
		}

		return e.complexity.Mask.Versions(childComplexity), true

	case "OutdatedPackage.Atom":
		if e.complexity.OutdatedPackage.Atom == nil {
			break
		}

		return e.complexity.OutdatedPackage.Atom(childComplexity), true

	case "OutdatedPackage.GentooVersion":
		if e.complexity.OutdatedPackage.GentooVersion == nil {
			break
		}

		return e.complexity.OutdatedPackage.GentooVersion(childComplexity), true

	case "OutdatedPackage.NewestVersion":
		if e.complexity.OutdatedPackage.NewestVersion == nil {
			break
		}

		return e.complexity.OutdatedPackage.NewestVersion(childComplexity), true

	case "Package.Atom":
		if e.complexity.Package.Atom == nil {
			break
		}

		return e.complexity.Package.Atom(childComplexity), true

	case "Package.Bugs":
		if e.complexity.Package.Bugs == nil {
			break
		}

		return e.complexity.Package.Bugs(childComplexity), true

	case "Package.Category":
		if e.complexity.Package.Category == nil {
			break
		}

		return e.complexity.Package.Category(childComplexity), true

	case "Package.Commits":
		if e.complexity.Package.Commits == nil {
			break
		}

		return e.complexity.Package.Commits(childComplexity), true

	case "Package.Longdescription":
		if e.complexity.Package.Longdescription == nil {
			break
		}

		return e.complexity.Package.Longdescription(childComplexity), true

	case "Package.Maintainers":
		if e.complexity.Package.Maintainers == nil {
			break
		}

		return e.complexity.Package.Maintainers(childComplexity), true

	case "Package.Name":
		if e.complexity.Package.Name == nil {
			break
		}

		return e.complexity.Package.Name(childComplexity), true

	case "Package.Outdated":
		if e.complexity.Package.Outdated == nil {
			break
		}

		return e.complexity.Package.Outdated(childComplexity), true

	case "Package.PkgCheckResults":
		if e.complexity.Package.PkgCheckResults == nil {
			break
		}

		return e.complexity.Package.PkgCheckResults(childComplexity), true

	case "Package.PrecedingCommits":
		if e.complexity.Package.PrecedingCommits == nil {
			break
		}

		return e.complexity.Package.PrecedingCommits(childComplexity), true

	case "Package.PullRequests":
		if e.complexity.Package.PullRequests == nil {
			break
		}

		return e.complexity.Package.PullRequests(childComplexity), true

	case "Package.ReverseDependencies":
		if e.complexity.Package.ReverseDependencies == nil {
			break
		}

		return e.complexity.Package.ReverseDependencies(childComplexity), true

	case "Package.Versions":
		if e.complexity.Package.Versions == nil {
			break
		}

		return e.complexity.Package.Versions(childComplexity), true

	case "PkgCheckResult.Atom":
		if e.complexity.PkgCheckResult.Atom == nil {
			break
		}

		return e.complexity.PkgCheckResult.Atom(childComplexity), true

	case "PkgCheckResult.CPV":
		if e.complexity.PkgCheckResult.CPV == nil {
			break
		}

		return e.complexity.PkgCheckResult.CPV(childComplexity), true

	case "PkgCheckResult.Category":
		if e.complexity.PkgCheckResult.Category == nil {
			break
		}

		return e.complexity.PkgCheckResult.Category(childComplexity), true

	case "PkgCheckResult.Class":
		if e.complexity.PkgCheckResult.Class == nil {
			break
		}

		return e.complexity.PkgCheckResult.Class(childComplexity), true

	case "PkgCheckResult.Message":
		if e.complexity.PkgCheckResult.Message == nil {
			break
		}

		return e.complexity.PkgCheckResult.Message(childComplexity), true

	case "PkgCheckResult.Package":
		if e.complexity.PkgCheckResult.Package == nil {
			break
		}

		return e.complexity.PkgCheckResult.Package(childComplexity), true

	case "PkgCheckResult.Version":
		if e.complexity.PkgCheckResult.Version == nil {
			break
		}

		return e.complexity.PkgCheckResult.Version(childComplexity), true

	case "Query.addedPackages":
		if e.complexity.Query.AddedPackages == nil {
			break
		}

		args, err := ec.field_Query_addedPackages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AddedPackages(childComplexity, args["Limit"].(*int)), true

	case "Query.application":
		if e.complexity.Query.Application == nil {
			break
		}

		return e.complexity.Query.Application(childComplexity), true

	case "Query.categories":
		if e.complexity.Query.Categories == nil {
			break
		}

		args, err := ec.field_Query_categories_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Categories(childComplexity, args["Name"].(*string), args["Description"].(*string)), true

	case "Query.category":
		if e.complexity.Query.Category == nil {
			break
		}

		args, err := ec.field_Query_category_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Category(childComplexity, args["Name"].(*string), args["Description"].(*string)), true

	case "Query.commit":
		if e.complexity.Query.Commit == nil {
			break
		}

		args, err := ec.field_Query_commit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Commit(childComplexity, args["Id"].(*string), args["PrecedingCommits"].(*int), args["AuthorName"].(*string), args["AuthorEmail"].(*string), args["AuthorDate"].(*time.Time), args["CommitterName"].(*string), args["CommitterEmail"].(*string), args["CommitterDate"].(*time.Time), args["Message"].(*string)), true

	case "Query.commits":
		if e.complexity.Query.Commits == nil {
			break
		}

		args, err := ec.field_Query_commits_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Commits(childComplexity, args["Id"].(*string), args["PrecedingCommits"].(*int), args["AuthorName"].(*string), args["AuthorEmail"].(*string), args["AuthorDate"].(*time.Time), args["CommitterName"].(*string), args["CommitterEmail"].(*string), args["CommitterDate"].(*time.Time), args["Message"].(*string)), true

	case "Query.keywordedVersions":
		if e.complexity.Query.KeywordedVersions == nil {
			break
		}

		args, err := ec.field_Query_keywordedVersions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.KeywordedVersions(childComplexity, args["Limit"].(*int), args["Arch"].(*string)), true

	case "Query.lastCommitTime":
		if e.complexity.Query.LastCommitTime == nil {
			break
		}

		return e.complexity.Query.LastCommitTime(childComplexity), true

	case "Query.mask":
		if e.complexity.Query.Mask == nil {
			break
		}

		args, err := ec.field_Query_mask_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Mask(childComplexity, args["Versions"].(*string), args["Author"].(*string), args["AuthorEmail"].(*string), args["Date"].(*time.Time), args["Reason"].(*string)), true

	case "Query.masks":
		if e.complexity.Query.Masks == nil {
			break
		}

		args, err := ec.field_Query_masks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Masks(childComplexity, args["Versions"].(*string), args["Author"].(*string), args["AuthorEmail"].(*string), args["Date"].(*time.Time), args["Reason"].(*string)), true

	case "Query.outdatedPackage":
		if e.complexity.Query.OutdatedPackage == nil {
			break
		}

		args, err := ec.field_Query_outdatedPackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.OutdatedPackage(childComplexity, args["Atom"].(*string), args["GentooVersion"].(*string), args["NewestVersion"].(*string)), true

	case "Query.outdatedPackages":
		if e.complexity.Query.OutdatedPackages == nil {
			break
		}

		args, err := ec.field_Query_outdatedPackages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.OutdatedPackages(childComplexity, args["Atom"].(*string), args["GentooVersion"].(*string), args["NewestVersion"].(*string)), true

	case "Query.package":
		if e.complexity.Query.Package == nil {
			break
		}

		args, err := ec.field_Query_package_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Package(childComplexity, args["Atom"].(*string), args["Category"].(*string), args["Name"].(*string), args["Longdescription"].(*string), args["PrecedingCommits"].(*int)), true

	case "Query.packageSearch":
		if e.complexity.Query.PackageSearch == nil {
			break
		}

		args, err := ec.field_Query_packageSearch_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PackageSearch(childComplexity, args["searchTerm"].(*string), args["resultSize"].(*int)), true

	case "Query.packages":
		if e.complexity.Query.Packages == nil {
			break
		}

		args, err := ec.field_Query_packages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Packages(childComplexity, args["Atom"].(*string), args["Category"].(*string), args["Name"].(*string), args["Longdescription"].(*string), args["PrecedingCommits"].(*int)), true

	case "Query.pkgCheckResult":
		if e.complexity.Query.PkgCheckResult == nil {
			break
		}

		args, err := ec.field_Query_pkgCheckResult_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PkgCheckResult(childComplexity, args["Atom"].(*string), args["Category"].(*string), args["Package"].(*string), args["Version"].(*string), args["CPV"].(*string), args["Class"].(*string), args["Message"].(*string)), true

	case "Query.pkgCheckResults":
		if e.complexity.Query.PkgCheckResults == nil {
			break
		}

		args, err := ec.field_Query_pkgCheckResults_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PkgCheckResults(childComplexity, args["Atom"].(*string), args["Category"].(*string), args["Package"].(*string), args["Version"].(*string), args["CPV"].(*string), args["Class"].(*string), args["Message"].(*string)), true

	case "Query.stabilizedVersions":
		if e.complexity.Query.StabilizedVersions == nil {
			break
		}

		args, err := ec.field_Query_stabilizedVersions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.StabilizedVersions(childComplexity, args["Limit"].(*int), args["Arch"].(*string)), true

	case "Query.updatedVersions":
		if e.complexity.Query.UpdatedVersions == nil {
			break
		}

		args, err := ec.field_Query_updatedVersions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UpdatedVersions(childComplexity, args["Limit"].(*int)), true

	case "Query.useflag":
		if e.complexity.Query.Useflag == nil {
			break
		}

		args, err := ec.field_Query_useflag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Useflag(childComplexity, args["Id"].(*string), args["Name"].(*string), args["Scope"].(*string), args["Description"].(*string), args["UseExpand"].(*string), args["Package"].(*string)), true

	case "Query.useflags":
		if e.complexity.Query.Useflags == nil {
			break
		}

		args, err := ec.field_Query_useflags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Useflags(childComplexity, args["Id"].(*string), args["Name"].(*string), args["Scope"].(*string), args["Description"].(*string), args["UseExpand"].(*string), args["Package"].(*string)), true

	case "Query.version":
		if e.complexity.Query.Version == nil {
			break
		}

		args, err := ec.field_Query_version_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Version(childComplexity, args["Id"].(*string), args["Category"].(*string), args["Package"].(*string), args["Atom"].(*string), args["Version"].(*string), args["Slot"].(*string), args["Subslot"].(*string), args["EAPI"].(*string), args["Keywords"].(*string), args["Useflags"].(*string), args["Restricts"].(*string), args["Properties"].(*string), args["Homepage"].(*string), args["License"].(*string), args["Description"].(*string)), true

	case "Query.versions":
		if e.complexity.Query.Versions == nil {
			break
		}

		args, err := ec.field_Query_versions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Versions(childComplexity, args["Id"].(*string), args["Category"].(*string), args["Package"].(*string), args["Atom"].(*string), args["Version"].(*string), args["Slot"].(*string), args["Subslot"].(*string), args["EAPI"].(*string), args["Keywords"].(*string), args["Useflags"].(*string), args["Restricts"].(*string), args["Properties"].(*string), args["Homepage"].(*string), args["License"].(*string), args["Description"].(*string)), true

	case "ReverseDependency.Atom":
		if e.complexity.ReverseDependency.Atom == nil {
			break
		}

		return e.complexity.ReverseDependency.Atom(childComplexity), true

	case "ReverseDependency.Condition":
		if e.complexity.ReverseDependency.Condition == nil {
			break
		}

		return e.complexity.ReverseDependency.Condition(childComplexity), true

	case "ReverseDependency.Id":
		if e.complexity.ReverseDependency.Id == nil {
			break
		}

		return e.complexity.ReverseDependency.Id(childComplexity), true

	case "ReverseDependency.ReverseDependencyAtom":
		if e.complexity.ReverseDependency.ReverseDependencyAtom == nil {
			break
		}

		return e.complexity.ReverseDependency.ReverseDependencyAtom(childComplexity), true

	case "ReverseDependency.ReverseDependencyVersion":
		if e.complexity.ReverseDependency.ReverseDependencyVersion == nil {
			break
		}

		return e.complexity.ReverseDependency.ReverseDependencyVersion(childComplexity), true

	case "ReverseDependency.Type":
		if e.complexity.ReverseDependency.Type == nil {
			break
		}

		return e.complexity.ReverseDependency.Type(childComplexity), true

	case "Useflag.Description":
		if e.complexity.Useflag.Description == nil {
			break
		}

		return e.complexity.Useflag.Description(childComplexity), true

	case "Useflag.Id":
		if e.complexity.Useflag.Id == nil {
			break
		}

		return e.complexity.Useflag.Id(childComplexity), true

	case "Useflag.Name":
		if e.complexity.Useflag.Name == nil {
			break
		}

		return e.complexity.Useflag.Name(childComplexity), true

	case "Useflag.Package":
		if e.complexity.Useflag.Package == nil {
			break
		}

		return e.complexity.Useflag.Package(childComplexity), true

	case "Useflag.Scope":
		if e.complexity.Useflag.Scope == nil {
			break
		}

		return e.complexity.Useflag.Scope(childComplexity), true

	case "Useflag.UseExpand":
		if e.complexity.Useflag.UseExpand == nil {
			break
		}

		return e.complexity.Useflag.UseExpand(childComplexity), true

	case "Version.Atom":
		if e.complexity.Version.Atom == nil {
			break
		}

		return e.complexity.Version.Atom(childComplexity), true

	case "Version.Category":
		if e.complexity.Version.Category == nil {
			break
		}

		return e.complexity.Version.Category(childComplexity), true

	case "Version.Commits":
		if e.complexity.Version.Commits == nil {
			break
		}

		return e.complexity.Version.Commits(childComplexity), true

	case "Version.Dependencies":
		if e.complexity.Version.Dependencies == nil {
			break
		}

		return e.complexity.Version.Dependencies(childComplexity), true

	case "Version.Description":
		if e.complexity.Version.Description == nil {
			break
		}

		return e.complexity.Version.Description(childComplexity), true

	case "Version.EAPI":
		if e.complexity.Version.EAPI == nil {
			break
		}

		return e.complexity.Version.EAPI(childComplexity), true

	case "Version.Homepage":
		if e.complexity.Version.Homepage == nil {
			break
		}

		return e.complexity.Version.Homepage(childComplexity), true

	case "Version.Id":
		if e.complexity.Version.Id == nil {
			break
		}

		return e.complexity.Version.Id(childComplexity), true

	case "Version.Keywords":
		if e.complexity.Version.Keywords == nil {
			break
		}

		return e.complexity.Version.Keywords(childComplexity), true

	case "Version.License":
		if e.complexity.Version.License == nil {
			break
		}

		return e.complexity.Version.License(childComplexity), true

	case "Version.Masks":
		if e.complexity.Version.Masks == nil {
			break
		}

		return e.complexity.Version.Masks(childComplexity), true

	case "Version.Package":
		if e.complexity.Version.Package == nil {
			break
		}

		return e.complexity.Version.Package(childComplexity), true

	case "Version.PkgCheckResults":
		if e.complexity.Version.PkgCheckResults == nil {
			break
		}

		return e.complexity.Version.PkgCheckResults(childComplexity), true

	case "Version.Properties":
		if e.complexity.Version.Properties == nil {
			break
		}

		return e.complexity.Version.Properties(childComplexity), true

	case "Version.Restricts":
		if e.complexity.Version.Restricts == nil {
			break
		}

		return e.complexity.Version.Restricts(childComplexity), true

	case "Version.Slot":
		if e.complexity.Version.Slot == nil {
			break
		}

		return e.complexity.Version.Slot(childComplexity), true

	case "Version.Subslot":
		if e.complexity.Version.Subslot == nil {
			break
		}

		return e.complexity.Version.Subslot(childComplexity), true

	case "Version.Useflags":
		if e.complexity.Version.Useflags == nil {
			break
		}

		return e.complexity.Version.Useflags(childComplexity), true

	case "Version.Version":
		if e.complexity.Version.Version == nil {
			break
		}

		return e.complexity.Version.Version(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	&ast.Source{Name: "internal/api/graphql/schema/directives.graphql", Input: `# GQL Directives
# This part is fairly necessary and is described in the gql documentation
# https://gqlgen.com/config/
directive @goModel(model: String, models: [String!]) on OBJECT
    | INPUT_OBJECT
    | SCALAR
    | ENUM
    | INTERFACE
    | UNION

directive @goField(forceResolver: Boolean, name: String) on INPUT_FIELD_DEFINITION
    | FIELD_DEFINITION`, BuiltIn: false},
	&ast.Source{Name: "internal/api/graphql/schema/query.graphql", Input: `"Different queries that can be used to get packages data"
type Query {

    "A query to get a single category by any of the given parameters. Multiple parameters can be used. In case the category can not identified uniquely by the given parameters, an error is returned."
    category(
        "Search by the name of the category"
        Name: String,
        "Search by the description of the category"
        Description: String
    ): Category

    "A query to get a list of categories filtered by the given parameters. The returned list may be empty."
    categories(
        "Search by the name of the category"
        Name: String,
        "Search by the description of the category"
        Description: String
    ): [Category]


    "A query to get a single commit by any of the given parameters. Multiple parameters can be used. In case the commit can not identified uniquely by the given parameters, an error is returned."
    commit(
        "Search by the id that is the hash of the commit"
        Id: String,
        "Search by the number of preceding that were submitted prior to this commit"
        PrecedingCommits: Int,
        "Search by the full name of the author"
        AuthorName: String,
        "Search by the email address of the author"
        AuthorEmail: String,
        "Search by the date of the author"
        AuthorDate: Time,
        "Search by the full name of the committer"
        CommitterName: String,
        "Search by the email address of the committer"
        CommitterEmail: String,
        "Search by the date of the committer"
        CommitterDate: Time,
        "Search by the commit message"
        Message: String
    ): Commit

    "A query to get a list of commits filtered by the given parameters. The returned list may be empty."
    commits(
        "Search by the id that is the hash of the commit"
        Id: String,
        "Search by the number of preceding that were submitted prior to this commit"
        PrecedingCommits: Int,
        "Search by the full name of the author"
        AuthorName: String,
        "Search by the email address of the author"
        AuthorEmail: String,
        "Search by the date of the author"
        AuthorDate: Time,
        "Search by the full name of the committer"
        CommitterName: String,
        "Search by the email address of the committer"
        CommitterEmail: String,
        "Search by the date of the committer"
        CommitterDate: Time,
        "Search by the commit message"
        Message: String
    ): [Commit]


    "A query to get a single mask entry by any of the given parameters. Multiple parameters can be used. In case the mask entry can not identified uniquely by the given parameters, an error is returned."
    mask(
        "Search by the version identifier that has been used to select the masked versions"
        Versions: String,
        "Search by full name of the author of the mask entry"
        Author: String,
        "Search by the email address of the author of the mask entry"
        AuthorEmail: String,
        "Search by the date of the mask entry"
        Date: Time,
        "Search by the specified reason of the mask entry"
        Reason: String
    ): Mask

    "A query to get a list of mask entries filtered by the given parameters. The returned list may be empty."
    masks(
        "Search by the version identifier that has been used to select the masked versions"
        Versions: String,
        "Search by full name of the author of the mask entry"
        Author: String,
        "Search by the email address of the author of the mask entry"
        AuthorEmail: String,
        "Search by the date of the mask entry"
        Date: Time,
        "Search by the specified reason of the mask entry"
        Reason: String
    ): [Mask]


    "A query to get a single outdatedPackage by any of the given parameters. Multiple parameters can be used. In case the outdatedPackage can not identified uniquely by the given parameters, an error is returned."
    outdatedPackage(
        "Search by the atom of the package that is outdated"
        Atom: String,
        "Search by the latest version of the package in Gentoo tree"
        GentooVersion: String,
        "Search by the latest version of the package upstream"
        NewestVersion: String
    ): OutdatedPackage

    "A query to get a list of outdatedPackages filtered by the given parameters. The returned list may be empty."
    outdatedPackages(
        "Search by the atom of the package that is outdated"
        Atom: String,
        "Search by the latest version of the package in Gentoo tree"
        GentooVersion: String,
        "Search by the latest version of the package upstream"
        NewestVersion: String
    ): [OutdatedPackage]


    "A query to get a single pkgCheckResult by any of the given parameters. Multiple parameters can be used. In case the pkgCheckResult can not identified uniquely by the given parameters, an error is returned."
    pkgCheckResult(
        "Search by the package atom of the version that is affected by the pkgcheck result"
        Atom: String,
        "Search by the package category of the version that is affected by the pkgcheck result"
        Category: String,
        "Search by the package name of the version that is affected by the pkgcheck result"
        Package: String,
        "Search by the version identifier of the version that is affected by the pkgcheck result"
        Version: String,
        "Search by the CPV of the version that is affected by the pkgcheck result"
        CPV: String,
        "Search by the class of the pkgcheck warning, e.g. DeprecatedEapi"
        Class: String,
        "Search by the message of the pkgcheck warning, e.g. 'uses deprecated EAPI 5'"
        Message: String
    ): PkgCheckResult

    "A query to get a list of pkgCheckResults filtered by the given parameters. The returned list may be empty."
    pkgCheckResults(
        "Search by the package atom of the version that is affected by the pkgcheck result"
        Atom: String,
        "Search by the package category of the version that is affected by the pkgcheck result"
        Category: String,
        "Search by the package name of the version that is affected by the pkgcheck result"
        Package: String,
        "Search by the version identifier of the version that is affected by the pkgcheck result"
        Version: String,
        "Search by the CPV of the version that is affected by the pkgcheck result"
        CPV: String,
        "Search by the class of the pkgcheck warning, e.g. DeprecatedEapi"
        Class: String,
        "Search by the message of the pkgcheck warning, e.g. 'uses deprecated EAPI 5'"
        Message: String
    ): [PkgCheckResult]


    "A query to get a single package by any of the given parameters. Multiple parameters can be used. In case the package can not identified uniquely by the given parameters, an error is returned."
    package(
        "Search by the atom of the package"
        Atom: String,
        "Search by the category of the package"
        Category: String,
        "Search by the package name of the package"
        Name: String,
        "Search by the long description of the package"
        Longdescription: String,
        "Search by the number of preceding commits before the package was added"
        PrecedingCommits: Int
    ): Package

    "A query to get a list of packages filtered by the given parameters. The returned list may be empty."
    packages(
        "Search by the atom of the package"
        Atom: String,
        "Search by the category of the package"
        Category: String,
        "Search by the package name of the package"
        Name: String,
        "Search by the long description of the package"
        Longdescription: String,
        "Search by the number of preceding commits before the package was added"
        PrecedingCommits: Int
    ): [Package]

    "A query to get a list of packages filtered by the given search query. The returned list my be empty."
    packageSearch(
        "Search by the given query"
        searchTerm: String
        "Return the first result only"
        resultSize: Int
    ): [Package]

    "A query to get a single useflag by any of the given parameters. Multiple parameters can be used. In case the useflag can not identified uniquely by the given parameters, an error is returned."
    useflag(
        "Search by the id of the useflag"
        Id: String,
        "Search by the name of the useflag"
        Name: String,
        "Search by the scope of the useflag, e.g. local or global"
        Scope: String,
        "Search by the description of the useflag"
        Description: String,
        "Search by the use expand"
        UseExpand: String,
        "Search by the package that belongs to the useflag in case it is a local useflag"
        Package: String
    ): Useflag

    "A query to get a list of useflags filtered by the given parameters. The returned list may be empty."
    useflags(
        "Search by the id of the useflag"
        Id: String,
        "Search by the name of the useflag"
        Name: String,
        "Search by the scope of the useflag, e.g. local or global"
        Scope: String,
        "Search by the description of the useflag"
        Description: String,
        "Search by the use expand"
        UseExpand: String,
        "Search by the package that belongs to the useflag in case it is a local useflag"
        Package: String
    ): [Useflag]


    "A query to get a single version by any of the given parameters. Multiple parameters can be used. In case the version can not identified uniquely by the given parameters, an error is returned."
    version(
        "Search by the id of the version"
        Id: String,
        "Search by the category of the package of the version"
        Category: String,
        "Search by the package name of the version"
        Package: String,
        "Search by the atom of the package of the version"
        Atom: String,
        "Search by the version identifier of the version"
        Version: String,
        "Search by the slot of the version"
        Slot: String,
        "Search by the subslot of the version"
        Subslot: String,
        "Search by the EAPI of the ebuild of the version"
        EAPI: String,
        "Search by the keywords of the version"
        Keywords: String,
        "Search by the useflags of the version"
        Useflags: String,
        "Search by the restricts information of the version"
        Restricts: String,
        "Search by the properties of the version"
        Properties: String,
        "Search by the homepage of the version"
        Homepage: String,
        "Search by the license of the version"
        License: String,
        "Search by the description of the version"
        Description: String
    ): Version

    "A query to get a list of versions filtered by the given parameters. The returned list may be empty."
    versions(
        "Search by the id of the version"
        Id: String,
        "Search by the category of the package of the version"
        Category: String,
        "Search by the package name of the version"
        Package: String,
        "Search by the atom of the package of the version"
        Atom: String,
        "Search by the version identifier of the version"
        Version: String,
        "Search by the slot of the version"
        Slot: String,
        "Search by the subslot of the version"
        Subslot: String,
        "Search by the EAPI of the ebuild of the version"
        EAPI: String,
        "Search by the keywords of the version"
        Keywords: String,
        "Search by the useflags of the version"
        Useflags: String,
        "Search by the restricts information of the version"
        Restricts: String,
        "Search by the properties of the version"
        Properties: String,
        "Search by the homepage of the version"
        Homepage: String,
        "Search by the license of the version"
        License: String,
        "Search by the description of the version"
        Description: String
    ): [Version]


    "A query to get the application information."
    application: Application

    "A query to get the last commit time."
    lastCommitTime: Time

    #
    # Shortcuts for convenience and easy migration
    #
    "A query to get the latest added packages. You have to specify the number of added packages that should be returned."
    addedPackages(
        "The number of added packages that should be returned"
        Limit: Int
    ): [Package]

    "A query to get the latest updated versions. You have to specify the number of updated versions that should be returned."
    updatedVersions(
        "The number of updated versions that should be returned"
        Limit: Int
    ): [Version]

    "A query to get the latest stabilized versions. You have to specify the number of stabilized versions that should be returned."
    stabilizedVersions(
        "The number of stabilized versions that should be returned"
        Limit: Int,
        "The arch that should be used to filter the results"
        Arch: String
    ): [Version]

    "A query to get the latest keyworded versions. You have to specify the number of keyworded versions that should be returned."
    keywordedVersions(
        "The number of keyworded versions that should be returned"
        Limit: Int,
        "The arch that should be used to filter the results"
        Arch: String
    ): [Version]
}
`, BuiltIn: false},
	&ast.Source{Name: "internal/api/graphql/schema/scalar.graphql", Input: `# gqlgen supports some custom scalars out of the box
# see: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/scalars.md

# resolves to time.Time
scalar Time

# resolves to map[string]interface{}
scalar Map

# resolves to interface{}
scalar Any
`, BuiltIn: false},
	&ast.Source{Name: "internal/api/graphql/schema/schema.graphql", Input: `schema {
    query: Query
}
`, BuiltIn: false},
	&ast.Source{Name: "internal/api/graphql/schema/types/Bug.graphql", Input: `"Information about Bugs"
type Bug
  @goModel(
    model: "github.com/expeditioneer/gentoo-soko/internal/models.Bug"
  ) {

  "The id of the bug."
  Id: String!

  "The product of the bug."
  Product: String!

  "The component of the bug."
  Component: String!

  "The assignee of the bug."
  Assignee: String!

  "The status of the bug."
  Status: String!

  "The summary of the bug."
  Summary: String!
}
`, BuiltIn: false},
	&ast.Source{Name: "internal/api/graphql/schema/types/GithubPullRequest.graphql", Input: `"Information about Github PullRequest"
type GithubPullRequest
  @goModel(
    model: "github.com/expeditioneer/gentoo-soko/internal/models.GithubPullRequest"
  ) {

  "The id of the pull request."
  Id: String!

  "True if the pull request is closed."
  Closed: Boolean!

  "The url of the pull request."
  Url: String!

  "The title of the pull request."
  Title: String!

  "The date of the creation of the pull request."
  CreatedAt: String!

  "The date of the last update of the pull request."
  UpdatedAt: String!

  "The CI state of the pull request."
  CiState: String!

  "The link to the CI state of the pull request."
  CiStateLink: String!

  "The labels of the pull request."
  Labels: [GitHubPullRequestLabelNode!]!

  "The number of comments."
  Comments: Int!

  "The changed files in the pull request11."
  Files: [GitHubPullRequestFileNode!]!

  "The author of the pull request."
  Author: String!
}


"Information about Github PullRequest Labels"
type GitHubPullRequestLabelNode
@goModel(
  model: "github.com/expeditioneer/gentoo-soko/internal/models.GitHubPullRequestLabelNode"
) {

  "The content / name of the label."
  Name: String!

  "The color of the label."
  Color: String!

}



"Information about Github PullRequest changed Files"
type GitHubPullRequestFileNode
@goModel(
  model: "github.com/expeditioneer/gentoo-soko/internal/models.GitHubPullRequestFileNode"
) {

  "The path of the changed file."
  Path: String!

  "The number of additions."
  Additions: Int!

  "The number of deletions."
  Deletions: Int!

}`, BuiltIn: false},
	&ast.Source{Name: "internal/api/graphql/schema/types/Mask.graphql", Input: `"A package's mask entry"
type Mask
  @goModel(
    model: "github.com/expeditioneer/gentoo-soko/internal/models.Mask"
  ) {

  "A string that describes all versions that are affected by this mask entry"
  Versions: String!

  "The autor of this mask entry"
  Author: String!

  "The email of the author of this mask entry"
  AuthorEmail: String!

  "The date of this mask entry"
  Date: Time!

  "The reason for masking this packages"
  Reason: String!
}
`, BuiltIn: false},
	&ast.Source{Name: "internal/api/graphql/schema/types/OutdatedPackage.graphql", Input: `"Information from repology about outdated packages in the Gentoo tree."
type OutdatedPackage
  @goModel(
    model: "github.com/expeditioneer/gentoo-soko/internal/models.OutdatedPackages"
  ) {

  "The atom of the affected package"
  Atom: String!

  "The latest version of the package that is present in the Gentoo tree"
  GentooVersion: String!

  "The latest version of the package that is present upstream. This version is greater than the latest version in the Gentoo tree."
  NewestVersion: String!
}
`, BuiltIn: false},
	&ast.Source{Name: "internal/api/graphql/schema/types/Package.graphql", Input: `"A Gentoo package"
type Package
  @goModel(
    model: "github.com/expeditioneer/gentoo-soko/internal/models.Package"
  ) {

  "The Atom of the package (category/package_name)"
  Atom: String!

  "The category of the package"
  Category: String!

  "The name of the package"
  Name: String!

  "An array containing all versions of package that are present"
  Versions: [Version!]!

  "The Longdescription of the package"
  Longdescription: String!

  "An array containing all maintainers of the package"
  Maintainers: [Maintainer!]!

  "An array containing all commits that have changed files containing to this package"
  Commits: [Commit!]!

  "The number of commits in the tree before the package has been added to the tree - this can be used to sort"
  PrecedingCommits: Int!

  "An array containing all pkgcheck warnings for this package"
  PkgCheckResults: [PkgCheckResult!]!

  "An array containing all repology warnings about new versions for this package"
  Outdated: [OutdatedPackage!]!

  "An array containing all bugs for this package"
  Bugs: [Bug!]!

  "An array containing all pull requests for this package"
  PullRequests: [GithubPullRequest!]!

  "An array containing all reverse dependencies for this package"
  ReverseDependencies: [ReverseDependency!]!
}

"Information about a maintainer of packages"
type Maintainer
  @goModel(
    model: "github.com/expeditioneer/gentoo-soko/internal/models.Maintainer"
  ) {

  "The full name of the maintainer"
  Name: String!

  "The email address of the maintainer"
  Email: String!

  "The type of the maintainer, e.g. project or person"
  Type: String!

  "The restrict information for this maintainer"
  Restrict: String!
}
`, BuiltIn: false},
	&ast.Source{Name: "internal/api/graphql/schema/types/PkgCheckResult.graphql", Input: `"A warning from pkgcheck for a version of a package"
type PkgCheckResult
  @goModel(
    model: "github.com/expeditioneer/gentoo-soko/internal/models.PkgCheckResult"
  ) {

  "The atom of the package that is affected by this pkgcheck warning"
  Atom: String!

  "The category of the package that is affected by this pkgcheck warning"
  Category: String!

  "The package name of the package that is affected by this pkgcheck warning"
  Package: String!

  "The version of the package that is affected by this pkgcheck warning"
  Version: String!

  "The CPV of the package that is affected by this pkgcheck warning"
  CPV: String!

  "The class of this warning, e.g. DeprecatedEapi"
  Class: String!

  "The message of this warning, e.g. 'uses deprecated EAPI 5'"
  Message: String!
}

`, BuiltIn: false},
	&ast.Source{Name: "internal/api/graphql/schema/types/ReverseDependency.graphql", Input: `"Information about Reverse Dependencies"
type ReverseDependency
  @goModel(
    model: "github.com/expeditioneer/gentoo-soko/internal/models.ReverseDependency"
  ) {

  "The id."
  Id: String!

  "The atom of the package."
  Atom: String!

  "The type of the dependency."
  Type: String!

  "The atom of the reverse dependency."
  ReverseDependencyAtom: String!

  "The version of the reverse depedency."
  ReverseDependencyVersion: String!

  "The condition for the dependency"
  Condition: String
}`, BuiltIn: false},
	&ast.Source{Name: "internal/api/graphql/schema/types/Version.graphql", Input: `"A version of a gentoo package"
type Version
  @goModel(
    model: "github.com/expeditioneer/gentoo-soko/internal/models.Version"
  ) {
  "The id i.e. CPV of a version to uniquely identify it"
  Id: String!

  "The category of the package of the version"
  Category: String!

  "The package name of the package of the version"
  Package: String!

  "The atom of the package of the version"
  Atom: String!

  "The version identifier of the version"
  Version: String!

  "The slot of the version"
  Slot: String!

  "The subslot of the version"
  Subslot: String!

  "The EAPI of the ebuild of the version"
  EAPI: String!

  "A string containing all keywords of the version"
  Keywords: String!

  "A list of all useflags of the version"
  Useflags: [String!]!

  "An array of restrict information for this version"
  Restricts: [String!]!

  "All properties of this version"
  Properties: [String!]!

  "An array of homepages of the package of this version"
  Homepage: [String!]!

  "The license of this version of the package"
  License: String!

  "The description of the version of this package"
  Description: String!

  "All commit objects that have affected this version"
  Commits: [Commit!]!

  "All mask entries that affect this version"
  Masks: [Mask!]!

  "An array of all pkgcheck results that affect this version"
  PkgCheckResults: [PkgCheckResult!]!

  "An array containing all dependencies of the version"
  Dependencies: [ReverseDependency!]!
}
`, BuiltIn: false},
	&ast.Source{Name: "internal/api/graphql/schema/types/application.graphql", Input: `"Contains general information about the application"
type Application
  @goModel(
    model: "github.com/expeditioneer/gentoo-soko/internal/models.Application"
  ) {
  "The version of the currently running application"
  Version: String!

  "The time of the last update of the application data"
  LastUpdate: Time!

  "The id / hash of the last commit that has been imported"
  LastCommit: String!
}
`, BuiltIn: false},
	&ast.Source{Name: "internal/api/graphql/schema/types/category.graphql", Input: `"Describes a Gentoo package category"
type Category
  @goModel(
    model: "github.com/expeditioneer/gentoo-soko/internal/models.Category"
  ) {
  "The name of the category"
  Name: String!

  "The description of the category"
  Description: String!

  "An array of all packages in this category"
  Packages: [Package!]!
}
`, BuiltIn: false},
	&ast.Source{Name: "internal/api/graphql/schema/types/commit.graphql", Input: `"A commit in the gentoo.git repository"
type Commit
  @goModel(
    model: "github.com/expeditioneer/gentoo-soko/internal/models.Commit"
  ) {
  "The hash of the commit, that is used to uniquely identify it"
  Id: String!

  "The number of preceding commits before this commit - this can be used to sort commits"
  PrecedingCommits: Int!

  "The full name of the author"
  AuthorName: String!

  "The email name of the author"
  AuthorEmail: String!

  "The date of the author"
  AuthorDate: Time!

  "The name of the committer"
  CommitterName: String!

  "The email name of the committer"
  CommitterEmail: String!

  "The date name of the committer"
  CommitterDate: Time!
  "The message of the commit"
  Message: String!

  "The changed files"
  ChangedFiles: ChangedFiles!

  "An array of packages that are affected by this commit"
  ChangedPackages: [Package!]!

  "An array of versions that are affected by this commit"
  ChangedVersions: [Version!]!

  "An array of KeywordChange objects that are affected by this commit"
  KeywordChanges: [KeywordChange!]!
}

"Describes all files that have been changed by a commit"
type ChangedFiles
@goModel(
  model: "github.com/expeditioneer/gentoo-soko/internal/models.ChangedFiles"
) {
  "All files that have been added by this commit"
  Added: [ChangedFile!]!

  "All files that have been modified by this commit"
  Modified: [ChangedFile!]!

  "All files that have been deleted by this commit"
  Deleted: [ChangedFile!]!
}

"Describes a changed file by a commit"
type ChangedFile
@goModel(
  model: "github.com/expeditioneer/gentoo-soko/internal/models.ChangedFile"
) {
  "The path to the changed file"
  Path: String!

  "The type of the change, e.g. A for added, M for modified or D for deleted"
  ChangeType: String!
}

"A keyword change of a commit"
type KeywordChange
@goModel(
  model: "github.com/expeditioneer/gentoo-soko/internal/models.KeywordChange"
) {
  "The id of the keyword change to uniquely identify the keyword change"
  Id: String!

  "The id / hash of the commit that triggered the keyword change"
  CommitId: String!

  "The commit object of the commit that triggered the keyword change"
  Commit: Commit!

  "The id of the version that is affected by this keyword change"
  VersionId: String!

  "The version object of the version that is affected by this keyword change"
  Version: Version!

  "The id of the package that is affected by this keyword change"
  PackageId: String!

  "The package object of the package that is affected by this keyword change"
  Package: Package!

  "An array of added keywords"
  Added: [String!]!

  "An array of stabilized keywords"
  Stabilized: [String!]!

  "An array of all keywords of the affected version"
  All: [String!]!
}
`, BuiltIn: false},
	&ast.Source{Name: "internal/api/graphql/schema/types/useflag.graphql", Input: `"A useflag"
type Useflag
  @goModel(
    model: "github.com/expeditioneer/gentoo-soko/internal/models.Useflag"
  ) {

  "The id of the useflag to uniquely identify the useflag"
  Id: ID!

  "The name of the useflag"
  Name: String!

  "The scope of the useflag, e.g. local or global useflag"
  Scope: String!

  "The description of the useflag"
  Description: String!

  "UseExpand, in case it's use expand flag"
  UseExpand: String!

  "The package this useflag belongs to, in case it's a local useflag"
  Package: String!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_addedPackages_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["Limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_categories_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Name"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Name"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Description"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Description"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_category_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Name"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Name"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Description"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Description"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_commit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Id"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Id"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["PrecedingCommits"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["PrecedingCommits"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["AuthorName"]; ok {
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["AuthorName"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["AuthorEmail"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["AuthorEmail"] = arg3
	var arg4 *time.Time
	if tmp, ok := rawArgs["AuthorDate"]; ok {
		arg4, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["AuthorDate"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["CommitterName"]; ok {
		arg5, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["CommitterName"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["CommitterEmail"]; ok {
		arg6, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["CommitterEmail"] = arg6
	var arg7 *time.Time
	if tmp, ok := rawArgs["CommitterDate"]; ok {
		arg7, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["CommitterDate"] = arg7
	var arg8 *string
	if tmp, ok := rawArgs["Message"]; ok {
		arg8, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Message"] = arg8
	return args, nil
}

func (ec *executionContext) field_Query_commits_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Id"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Id"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["PrecedingCommits"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["PrecedingCommits"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["AuthorName"]; ok {
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["AuthorName"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["AuthorEmail"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["AuthorEmail"] = arg3
	var arg4 *time.Time
	if tmp, ok := rawArgs["AuthorDate"]; ok {
		arg4, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["AuthorDate"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["CommitterName"]; ok {
		arg5, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["CommitterName"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["CommitterEmail"]; ok {
		arg6, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["CommitterEmail"] = arg6
	var arg7 *time.Time
	if tmp, ok := rawArgs["CommitterDate"]; ok {
		arg7, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["CommitterDate"] = arg7
	var arg8 *string
	if tmp, ok := rawArgs["Message"]; ok {
		arg8, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Message"] = arg8
	return args, nil
}

func (ec *executionContext) field_Query_keywordedVersions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["Limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Limit"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Arch"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Arch"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_mask_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Versions"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Versions"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Author"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Author"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["AuthorEmail"]; ok {
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["AuthorEmail"] = arg2
	var arg3 *time.Time
	if tmp, ok := rawArgs["Date"]; ok {
		arg3, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Date"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["Reason"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Reason"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_masks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Versions"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Versions"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Author"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Author"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["AuthorEmail"]; ok {
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["AuthorEmail"] = arg2
	var arg3 *time.Time
	if tmp, ok := rawArgs["Date"]; ok {
		arg3, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Date"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["Reason"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Reason"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_outdatedPackage_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Atom"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Atom"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["GentooVersion"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["GentooVersion"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["NewestVersion"]; ok {
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["NewestVersion"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_outdatedPackages_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Atom"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Atom"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["GentooVersion"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["GentooVersion"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["NewestVersion"]; ok {
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["NewestVersion"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_packageSearch_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["searchTerm"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["searchTerm"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["resultSize"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resultSize"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_package_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Atom"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Atom"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Category"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Category"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["Name"]; ok {
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Name"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["Longdescription"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Longdescription"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["PrecedingCommits"]; ok {
		arg4, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["PrecedingCommits"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_packages_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Atom"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Atom"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Category"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Category"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["Name"]; ok {
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Name"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["Longdescription"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Longdescription"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["PrecedingCommits"]; ok {
		arg4, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["PrecedingCommits"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_pkgCheckResult_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Atom"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Atom"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Category"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Category"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["Package"]; ok {
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Package"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["Version"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Version"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["CPV"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["CPV"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["Class"]; ok {
		arg5, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Class"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["Message"]; ok {
		arg6, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Message"] = arg6
	return args, nil
}

func (ec *executionContext) field_Query_pkgCheckResults_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Atom"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Atom"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Category"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Category"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["Package"]; ok {
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Package"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["Version"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Version"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["CPV"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["CPV"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["Class"]; ok {
		arg5, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Class"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["Message"]; ok {
		arg6, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Message"] = arg6
	return args, nil
}

func (ec *executionContext) field_Query_stabilizedVersions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["Limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Limit"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Arch"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Arch"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_updatedVersions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["Limit"]; ok {
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_useflag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Id"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Id"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Name"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Name"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["Scope"]; ok {
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Scope"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["Description"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Description"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["UseExpand"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["UseExpand"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["Package"]; ok {
		arg5, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Package"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_useflags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Id"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Id"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Name"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Name"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["Scope"]; ok {
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Scope"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["Description"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Description"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["UseExpand"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["UseExpand"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["Package"]; ok {
		arg5, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Package"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_version_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Id"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Id"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Category"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Category"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["Package"]; ok {
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Package"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["Atom"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Atom"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["Version"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Version"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["Slot"]; ok {
		arg5, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Slot"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["Subslot"]; ok {
		arg6, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Subslot"] = arg6
	var arg7 *string
	if tmp, ok := rawArgs["EAPI"]; ok {
		arg7, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["EAPI"] = arg7
	var arg8 *string
	if tmp, ok := rawArgs["Keywords"]; ok {
		arg8, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Keywords"] = arg8
	var arg9 *string
	if tmp, ok := rawArgs["Useflags"]; ok {
		arg9, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Useflags"] = arg9
	var arg10 *string
	if tmp, ok := rawArgs["Restricts"]; ok {
		arg10, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Restricts"] = arg10
	var arg11 *string
	if tmp, ok := rawArgs["Properties"]; ok {
		arg11, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Properties"] = arg11
	var arg12 *string
	if tmp, ok := rawArgs["Homepage"]; ok {
		arg12, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Homepage"] = arg12
	var arg13 *string
	if tmp, ok := rawArgs["License"]; ok {
		arg13, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["License"] = arg13
	var arg14 *string
	if tmp, ok := rawArgs["Description"]; ok {
		arg14, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Description"] = arg14
	return args, nil
}

func (ec *executionContext) field_Query_versions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Id"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Id"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Category"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Category"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["Package"]; ok {
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Package"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["Atom"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Atom"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["Version"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Version"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["Slot"]; ok {
		arg5, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Slot"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["Subslot"]; ok {
		arg6, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Subslot"] = arg6
	var arg7 *string
	if tmp, ok := rawArgs["EAPI"]; ok {
		arg7, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["EAPI"] = arg7
	var arg8 *string
	if tmp, ok := rawArgs["Keywords"]; ok {
		arg8, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Keywords"] = arg8
	var arg9 *string
	if tmp, ok := rawArgs["Useflags"]; ok {
		arg9, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Useflags"] = arg9
	var arg10 *string
	if tmp, ok := rawArgs["Restricts"]; ok {
		arg10, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Restricts"] = arg10
	var arg11 *string
	if tmp, ok := rawArgs["Properties"]; ok {
		arg11, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Properties"] = arg11
	var arg12 *string
	if tmp, ok := rawArgs["Homepage"]; ok {
		arg12, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Homepage"] = arg12
	var arg13 *string
	if tmp, ok := rawArgs["License"]; ok {
		arg13, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["License"] = arg13
	var arg14 *string
	if tmp, ok := rawArgs["Description"]; ok {
		arg14, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Description"] = arg14
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Application_Version(ctx context.Context, field graphql.CollectedField, obj *models.Application) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Application",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Application_LastUpdate(ctx context.Context, field graphql.CollectedField, obj *models.Application) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Application",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Application_LastCommit(ctx context.Context, field graphql.CollectedField, obj *models.Application) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Application",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastCommit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Bug_Id(ctx context.Context, field graphql.CollectedField, obj *models.Bug) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Bug",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Bug_Product(ctx context.Context, field graphql.CollectedField, obj *models.Bug) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Bug",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Product, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Bug_Component(ctx context.Context, field graphql.CollectedField, obj *models.Bug) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Bug",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Component, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Bug_Assignee(ctx context.Context, field graphql.CollectedField, obj *models.Bug) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Bug",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Assignee, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Bug_Status(ctx context.Context, field graphql.CollectedField, obj *models.Bug) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Bug",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Bug_Summary(ctx context.Context, field graphql.CollectedField, obj *models.Bug) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Bug",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Summary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Category_Name(ctx context.Context, field graphql.CollectedField, obj *models.Category) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Category",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Category_Description(ctx context.Context, field graphql.CollectedField, obj *models.Category) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Category",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Category_Packages(ctx context.Context, field graphql.CollectedField, obj *models.Category) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Category",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Packages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Package)
	fc.Result = res
	return ec.marshalNPackage2ᚕᚖsokoᚋpkgᚋmodelsᚐPackageᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangedFile_Path(ctx context.Context, field graphql.CollectedField, obj *models.ChangedFile) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChangedFile",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangedFile_ChangeType(ctx context.Context, field graphql.CollectedField, obj *models.ChangedFile) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChangedFile",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangeType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangedFiles_Added(ctx context.Context, field graphql.CollectedField, obj *models.ChangedFiles) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChangedFiles",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Added, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.ChangedFile)
	fc.Result = res
	return ec.marshalNChangedFile2ᚕᚖsokoᚋpkgᚋmodelsᚐChangedFileᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangedFiles_Modified(ctx context.Context, field graphql.CollectedField, obj *models.ChangedFiles) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChangedFiles",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Modified, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.ChangedFile)
	fc.Result = res
	return ec.marshalNChangedFile2ᚕᚖsokoᚋpkgᚋmodelsᚐChangedFileᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ChangedFiles_Deleted(ctx context.Context, field graphql.CollectedField, obj *models.ChangedFiles) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChangedFiles",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deleted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.ChangedFile)
	fc.Result = res
	return ec.marshalNChangedFile2ᚕᚖsokoᚋpkgᚋmodelsᚐChangedFileᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_Id(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_PrecedingCommits(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrecedingCommits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_AuthorName(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_AuthorEmail(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_AuthorDate(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_CommitterName(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitterName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_CommitterEmail(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitterEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_CommitterDate(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitterDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_Message(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_ChangedFiles(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangedFiles, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.ChangedFiles)
	fc.Result = res
	return ec.marshalNChangedFiles2ᚖsokoᚋpkgᚋmodelsᚐChangedFiles(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_ChangedPackages(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangedPackages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Package)
	fc.Result = res
	return ec.marshalNPackage2ᚕᚖsokoᚋpkgᚋmodelsᚐPackageᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_ChangedVersions(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangedVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Version)
	fc.Result = res
	return ec.marshalNVersion2ᚕᚖsokoᚋpkgᚋmodelsᚐVersionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_KeywordChanges(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KeywordChanges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.KeywordChange)
	fc.Result = res
	return ec.marshalNKeywordChange2ᚕᚖsokoᚋpkgᚋmodelsᚐKeywordChangeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _GitHubPullRequestFileNode_Path(ctx context.Context, field graphql.CollectedField, obj *models.GitHubPullRequestFileNode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitHubPullRequestFileNode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GitHubPullRequestFileNode_Additions(ctx context.Context, field graphql.CollectedField, obj *models.GitHubPullRequestFileNode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitHubPullRequestFileNode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Additions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GitHubPullRequestFileNode_Deletions(ctx context.Context, field graphql.CollectedField, obj *models.GitHubPullRequestFileNode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitHubPullRequestFileNode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deletions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GitHubPullRequestLabelNode_Name(ctx context.Context, field graphql.CollectedField, obj *models.GitHubPullRequestLabelNode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitHubPullRequestLabelNode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GitHubPullRequestLabelNode_Color(ctx context.Context, field graphql.CollectedField, obj *models.GitHubPullRequestLabelNode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitHubPullRequestLabelNode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Color, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GithubPullRequest_Id(ctx context.Context, field graphql.CollectedField, obj *models.GithubPullRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GithubPullRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GithubPullRequest_Closed(ctx context.Context, field graphql.CollectedField, obj *models.GithubPullRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GithubPullRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Closed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _GithubPullRequest_Url(ctx context.Context, field graphql.CollectedField, obj *models.GithubPullRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GithubPullRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Url, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GithubPullRequest_Title(ctx context.Context, field graphql.CollectedField, obj *models.GithubPullRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GithubPullRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GithubPullRequest_CreatedAt(ctx context.Context, field graphql.CollectedField, obj *models.GithubPullRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GithubPullRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GithubPullRequest_UpdatedAt(ctx context.Context, field graphql.CollectedField, obj *models.GithubPullRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GithubPullRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GithubPullRequest_CiState(ctx context.Context, field graphql.CollectedField, obj *models.GithubPullRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GithubPullRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CiState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GithubPullRequest_CiStateLink(ctx context.Context, field graphql.CollectedField, obj *models.GithubPullRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GithubPullRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CiStateLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GithubPullRequest_Labels(ctx context.Context, field graphql.CollectedField, obj *models.GithubPullRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GithubPullRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.GitHubPullRequestLabelNode)
	fc.Result = res
	return ec.marshalNGitHubPullRequestLabelNode2ᚕsokoᚋpkgᚋmodelsᚐGitHubPullRequestLabelNodeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _GithubPullRequest_Comments(ctx context.Context, field graphql.CollectedField, obj *models.GithubPullRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GithubPullRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Comments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _GithubPullRequest_Files(ctx context.Context, field graphql.CollectedField, obj *models.GithubPullRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GithubPullRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Files, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.GitHubPullRequestFileNode)
	fc.Result = res
	return ec.marshalNGitHubPullRequestFileNode2ᚕsokoᚋpkgᚋmodelsᚐGitHubPullRequestFileNodeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _GithubPullRequest_Author(ctx context.Context, field graphql.CollectedField, obj *models.GithubPullRequest) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GithubPullRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Author, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _KeywordChange_Id(ctx context.Context, field graphql.CollectedField, obj *models.KeywordChange) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KeywordChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _KeywordChange_CommitId(ctx context.Context, field graphql.CollectedField, obj *models.KeywordChange) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KeywordChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _KeywordChange_Commit(ctx context.Context, field graphql.CollectedField, obj *models.KeywordChange) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KeywordChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Commit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Commit)
	fc.Result = res
	return ec.marshalNCommit2ᚖsokoᚋpkgᚋmodelsᚐCommit(ctx, field.Selections, res)
}

func (ec *executionContext) _KeywordChange_VersionId(ctx context.Context, field graphql.CollectedField, obj *models.KeywordChange) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KeywordChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VersionId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _KeywordChange_Version(ctx context.Context, field graphql.CollectedField, obj *models.KeywordChange) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KeywordChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Version)
	fc.Result = res
	return ec.marshalNVersion2ᚖsokoᚋpkgᚋmodelsᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _KeywordChange_PackageId(ctx context.Context, field graphql.CollectedField, obj *models.KeywordChange) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KeywordChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PackageId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _KeywordChange_Package(ctx context.Context, field graphql.CollectedField, obj *models.KeywordChange) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KeywordChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Package, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Package)
	fc.Result = res
	return ec.marshalNPackage2ᚖsokoᚋpkgᚋmodelsᚐPackage(ctx, field.Selections, res)
}

func (ec *executionContext) _KeywordChange_Added(ctx context.Context, field graphql.CollectedField, obj *models.KeywordChange) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KeywordChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Added, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _KeywordChange_Stabilized(ctx context.Context, field graphql.CollectedField, obj *models.KeywordChange) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KeywordChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stabilized, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _KeywordChange_All(ctx context.Context, field graphql.CollectedField, obj *models.KeywordChange) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KeywordChange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.All, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_Name(ctx context.Context, field graphql.CollectedField, obj *models.Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Maintainer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_Email(ctx context.Context, field graphql.CollectedField, obj *models.Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Maintainer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_Type(ctx context.Context, field graphql.CollectedField, obj *models.Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Maintainer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_Restrict(ctx context.Context, field graphql.CollectedField, obj *models.Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Maintainer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Restrict, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mask_Versions(ctx context.Context, field graphql.CollectedField, obj *models.Mask) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mask",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Versions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mask_Author(ctx context.Context, field graphql.CollectedField, obj *models.Mask) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mask",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Author, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mask_AuthorEmail(ctx context.Context, field graphql.CollectedField, obj *models.Mask) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mask",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mask_Date(ctx context.Context, field graphql.CollectedField, obj *models.Mask) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mask",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Mask_Reason(ctx context.Context, field graphql.CollectedField, obj *models.Mask) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mask",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OutdatedPackage_Atom(ctx context.Context, field graphql.CollectedField, obj *models.OutdatedPackages) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OutdatedPackage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Atom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OutdatedPackage_GentooVersion(ctx context.Context, field graphql.CollectedField, obj *models.OutdatedPackages) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OutdatedPackage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GentooVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OutdatedPackage_NewestVersion(ctx context.Context, field graphql.CollectedField, obj *models.OutdatedPackages) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "OutdatedPackage",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewestVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_Atom(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Atom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_Category(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_Name(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_Versions(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Versions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Version)
	fc.Result = res
	return ec.marshalNVersion2ᚕᚖsokoᚋpkgᚋmodelsᚐVersionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_Longdescription(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Longdescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_Maintainers(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Maintainers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Maintainer)
	fc.Result = res
	return ec.marshalNMaintainer2ᚕᚖsokoᚋpkgᚋmodelsᚐMaintainerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_Commits(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Commits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Commit)
	fc.Result = res
	return ec.marshalNCommit2ᚕᚖsokoᚋpkgᚋmodelsᚐCommitᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_PrecedingCommits(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrecedingCommits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_PkgCheckResults(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PkgCheckResults, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.PkgCheckResult)
	fc.Result = res
	return ec.marshalNPkgCheckResult2ᚕᚖsokoᚋpkgᚋmodelsᚐPkgCheckResultᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_Outdated(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Outdated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.OutdatedPackages)
	fc.Result = res
	return ec.marshalNOutdatedPackage2ᚕᚖsokoᚋpkgᚋmodelsᚐOutdatedPackagesᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_Bugs(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bugs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Bug)
	fc.Result = res
	return ec.marshalNBug2ᚕᚖsokoᚋpkgᚋmodelsᚐBugᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_PullRequests(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PullRequests, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.GithubPullRequest)
	fc.Result = res
	return ec.marshalNGithubPullRequest2ᚕᚖsokoᚋpkgᚋmodelsᚐGithubPullRequestᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Package_ReverseDependencies(ctx context.Context, field graphql.CollectedField, obj *models.Package) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Package",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReverseDependencies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.ReverseDependency)
	fc.Result = res
	return ec.marshalNReverseDependency2ᚕᚖsokoᚋpkgᚋmodelsᚐReverseDependencyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _PkgCheckResult_Atom(ctx context.Context, field graphql.CollectedField, obj *models.PkgCheckResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PkgCheckResult",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Atom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PkgCheckResult_Category(ctx context.Context, field graphql.CollectedField, obj *models.PkgCheckResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PkgCheckResult",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PkgCheckResult_Package(ctx context.Context, field graphql.CollectedField, obj *models.PkgCheckResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PkgCheckResult",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Package, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PkgCheckResult_Version(ctx context.Context, field graphql.CollectedField, obj *models.PkgCheckResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PkgCheckResult",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PkgCheckResult_CPV(ctx context.Context, field graphql.CollectedField, obj *models.PkgCheckResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PkgCheckResult",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CPV, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PkgCheckResult_Class(ctx context.Context, field graphql.CollectedField, obj *models.PkgCheckResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PkgCheckResult",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Class, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PkgCheckResult_Message(ctx context.Context, field graphql.CollectedField, obj *models.PkgCheckResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PkgCheckResult",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_category(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_category_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Category(rctx, args["Name"].(*string), args["Description"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Category)
	fc.Result = res
	return ec.marshalOCategory2ᚖsokoᚋpkgᚋmodelsᚐCategory(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_categories(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_categories_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Categories(rctx, args["Name"].(*string), args["Description"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Category)
	fc.Result = res
	return ec.marshalOCategory2ᚕᚖsokoᚋpkgᚋmodelsᚐCategory(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_commit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_commit_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Commit(rctx, args["Id"].(*string), args["PrecedingCommits"].(*int), args["AuthorName"].(*string), args["AuthorEmail"].(*string), args["AuthorDate"].(*time.Time), args["CommitterName"].(*string), args["CommitterEmail"].(*string), args["CommitterDate"].(*time.Time), args["Message"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Commit)
	fc.Result = res
	return ec.marshalOCommit2ᚖsokoᚋpkgᚋmodelsᚐCommit(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_commits(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_commits_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Commits(rctx, args["Id"].(*string), args["PrecedingCommits"].(*int), args["AuthorName"].(*string), args["AuthorEmail"].(*string), args["AuthorDate"].(*time.Time), args["CommitterName"].(*string), args["CommitterEmail"].(*string), args["CommitterDate"].(*time.Time), args["Message"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Commit)
	fc.Result = res
	return ec.marshalOCommit2ᚕᚖsokoᚋpkgᚋmodelsᚐCommit(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_mask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_mask_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Mask(rctx, args["Versions"].(*string), args["Author"].(*string), args["AuthorEmail"].(*string), args["Date"].(*time.Time), args["Reason"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Mask)
	fc.Result = res
	return ec.marshalOMask2ᚖsokoᚋpkgᚋmodelsᚐMask(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_masks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_masks_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Masks(rctx, args["Versions"].(*string), args["Author"].(*string), args["AuthorEmail"].(*string), args["Date"].(*time.Time), args["Reason"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Mask)
	fc.Result = res
	return ec.marshalOMask2ᚕᚖsokoᚋpkgᚋmodelsᚐMask(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_outdatedPackage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_outdatedPackage_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().OutdatedPackage(rctx, args["Atom"].(*string), args["GentooVersion"].(*string), args["NewestVersion"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.OutdatedPackages)
	fc.Result = res
	return ec.marshalOOutdatedPackage2ᚖsokoᚋpkgᚋmodelsᚐOutdatedPackages(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_outdatedPackages(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_outdatedPackages_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().OutdatedPackages(rctx, args["Atom"].(*string), args["GentooVersion"].(*string), args["NewestVersion"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.OutdatedPackages)
	fc.Result = res
	return ec.marshalOOutdatedPackage2ᚕᚖsokoᚋpkgᚋmodelsᚐOutdatedPackages(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_pkgCheckResult(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_pkgCheckResult_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PkgCheckResult(rctx, args["Atom"].(*string), args["Category"].(*string), args["Package"].(*string), args["Version"].(*string), args["CPV"].(*string), args["Class"].(*string), args["Message"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.PkgCheckResult)
	fc.Result = res
	return ec.marshalOPkgCheckResult2ᚖsokoᚋpkgᚋmodelsᚐPkgCheckResult(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_pkgCheckResults(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_pkgCheckResults_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PkgCheckResults(rctx, args["Atom"].(*string), args["Category"].(*string), args["Package"].(*string), args["Version"].(*string), args["CPV"].(*string), args["Class"].(*string), args["Message"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.PkgCheckResult)
	fc.Result = res
	return ec.marshalOPkgCheckResult2ᚕᚖsokoᚋpkgᚋmodelsᚐPkgCheckResult(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_package(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_package_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Package(rctx, args["Atom"].(*string), args["Category"].(*string), args["Name"].(*string), args["Longdescription"].(*string), args["PrecedingCommits"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Package)
	fc.Result = res
	return ec.marshalOPackage2ᚖsokoᚋpkgᚋmodelsᚐPackage(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_packages(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_packages_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Packages(rctx, args["Atom"].(*string), args["Category"].(*string), args["Name"].(*string), args["Longdescription"].(*string), args["PrecedingCommits"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Package)
	fc.Result = res
	return ec.marshalOPackage2ᚕᚖsokoᚋpkgᚋmodelsᚐPackage(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_packageSearch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_packageSearch_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PackageSearch(rctx, args["searchTerm"].(*string), args["resultSize"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Package)
	fc.Result = res
	return ec.marshalOPackage2ᚕᚖsokoᚋpkgᚋmodelsᚐPackage(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_useflag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_useflag_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Useflag(rctx, args["Id"].(*string), args["Name"].(*string), args["Scope"].(*string), args["Description"].(*string), args["UseExpand"].(*string), args["Package"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Useflag)
	fc.Result = res
	return ec.marshalOUseflag2ᚖsokoᚋpkgᚋmodelsᚐUseflag(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_useflags(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_useflags_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Useflags(rctx, args["Id"].(*string), args["Name"].(*string), args["Scope"].(*string), args["Description"].(*string), args["UseExpand"].(*string), args["Package"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Useflag)
	fc.Result = res
	return ec.marshalOUseflag2ᚕᚖsokoᚋpkgᚋmodelsᚐUseflag(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_version(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_version_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Version(rctx, args["Id"].(*string), args["Category"].(*string), args["Package"].(*string), args["Atom"].(*string), args["Version"].(*string), args["Slot"].(*string), args["Subslot"].(*string), args["EAPI"].(*string), args["Keywords"].(*string), args["Useflags"].(*string), args["Restricts"].(*string), args["Properties"].(*string), args["Homepage"].(*string), args["License"].(*string), args["Description"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Version)
	fc.Result = res
	return ec.marshalOVersion2ᚖsokoᚋpkgᚋmodelsᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_versions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_versions_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Versions(rctx, args["Id"].(*string), args["Category"].(*string), args["Package"].(*string), args["Atom"].(*string), args["Version"].(*string), args["Slot"].(*string), args["Subslot"].(*string), args["EAPI"].(*string), args["Keywords"].(*string), args["Useflags"].(*string), args["Restricts"].(*string), args["Properties"].(*string), args["Homepage"].(*string), args["License"].(*string), args["Description"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Version)
	fc.Result = res
	return ec.marshalOVersion2ᚕᚖsokoᚋpkgᚋmodelsᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_application(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Application(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Application)
	fc.Result = res
	return ec.marshalOApplication2ᚖsokoᚋpkgᚋmodelsᚐApplication(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_lastCommitTime(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().LastCommitTime(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_addedPackages(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_addedPackages_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AddedPackages(rctx, args["Limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Package)
	fc.Result = res
	return ec.marshalOPackage2ᚕᚖsokoᚋpkgᚋmodelsᚐPackage(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_updatedVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_updatedVersions_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UpdatedVersions(rctx, args["Limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Version)
	fc.Result = res
	return ec.marshalOVersion2ᚕᚖsokoᚋpkgᚋmodelsᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_stabilizedVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_stabilizedVersions_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().StabilizedVersions(rctx, args["Limit"].(*int), args["Arch"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Version)
	fc.Result = res
	return ec.marshalOVersion2ᚕᚖsokoᚋpkgᚋmodelsᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_keywordedVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_keywordedVersions_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().KeywordedVersions(rctx, args["Limit"].(*int), args["Arch"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Version)
	fc.Result = res
	return ec.marshalOVersion2ᚕᚖsokoᚋpkgᚋmodelsᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _ReverseDependency_Id(ctx context.Context, field graphql.CollectedField, obj *models.ReverseDependency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ReverseDependency",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ReverseDependency_Atom(ctx context.Context, field graphql.CollectedField, obj *models.ReverseDependency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ReverseDependency",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Atom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ReverseDependency_Type(ctx context.Context, field graphql.CollectedField, obj *models.ReverseDependency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ReverseDependency",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ReverseDependency_ReverseDependencyAtom(ctx context.Context, field graphql.CollectedField, obj *models.ReverseDependency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ReverseDependency",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReverseDependencyAtom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ReverseDependency_ReverseDependencyVersion(ctx context.Context, field graphql.CollectedField, obj *models.ReverseDependency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ReverseDependency",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReverseDependencyVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ReverseDependency_Condition(ctx context.Context, field graphql.CollectedField, obj *models.ReverseDependency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ReverseDependency",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Condition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Useflag_Id(ctx context.Context, field graphql.CollectedField, obj *models.Useflag) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Useflag",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Useflag_Name(ctx context.Context, field graphql.CollectedField, obj *models.Useflag) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Useflag",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Useflag_Scope(ctx context.Context, field graphql.CollectedField, obj *models.Useflag) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Useflag",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Scope, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Useflag_Description(ctx context.Context, field graphql.CollectedField, obj *models.Useflag) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Useflag",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Useflag_UseExpand(ctx context.Context, field graphql.CollectedField, obj *models.Useflag) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Useflag",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UseExpand, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Useflag_Package(ctx context.Context, field graphql.CollectedField, obj *models.Useflag) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Useflag",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Package, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Id(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Category(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Package(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Package, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Atom(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Atom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Version(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Slot(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Slot, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Subslot(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subslot, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_EAPI(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EAPI, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Keywords(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Keywords, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Useflags(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Useflags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Restricts(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Restricts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Properties(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Properties, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Homepage(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Homepage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_License(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.License, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Description(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Commits(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Commits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Commit)
	fc.Result = res
	return ec.marshalNCommit2ᚕᚖsokoᚋpkgᚋmodelsᚐCommitᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Masks(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Masks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Mask)
	fc.Result = res
	return ec.marshalNMask2ᚕᚖsokoᚋpkgᚋmodelsᚐMaskᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_PkgCheckResults(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PkgCheckResults, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.PkgCheckResult)
	fc.Result = res
	return ec.marshalNPkgCheckResult2ᚕᚖsokoᚋpkgᚋmodelsᚐPkgCheckResultᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Version_Dependencies(ctx context.Context, field graphql.CollectedField, obj *models.Version) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Version",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dependencies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.ReverseDependency)
	fc.Result = res
	return ec.marshalNReverseDependency2ᚕᚖsokoᚋpkgᚋmodelsᚐReverseDependencyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var applicationImplementors = []string{"Application"}

func (ec *executionContext) _Application(ctx context.Context, sel ast.SelectionSet, obj *models.Application) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Application")
		case "Version":
			out.Values[i] = ec._Application_Version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "LastUpdate":
			out.Values[i] = ec._Application_LastUpdate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "LastCommit":
			out.Values[i] = ec._Application_LastCommit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var bugImplementors = []string{"Bug"}

func (ec *executionContext) _Bug(ctx context.Context, sel ast.SelectionSet, obj *models.Bug) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bugImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Bug")
		case "Id":
			out.Values[i] = ec._Bug_Id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Product":
			out.Values[i] = ec._Bug_Product(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Component":
			out.Values[i] = ec._Bug_Component(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Assignee":
			out.Values[i] = ec._Bug_Assignee(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Status":
			out.Values[i] = ec._Bug_Status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Summary":
			out.Values[i] = ec._Bug_Summary(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var categoryImplementors = []string{"Category"}

func (ec *executionContext) _Category(ctx context.Context, sel ast.SelectionSet, obj *models.Category) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, categoryImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Category")
		case "Name":
			out.Values[i] = ec._Category_Name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Description":
			out.Values[i] = ec._Category_Description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Packages":
			out.Values[i] = ec._Category_Packages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var changedFileImplementors = []string{"ChangedFile"}

func (ec *executionContext) _ChangedFile(ctx context.Context, sel ast.SelectionSet, obj *models.ChangedFile) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, changedFileImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChangedFile")
		case "Path":
			out.Values[i] = ec._ChangedFile_Path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ChangeType":
			out.Values[i] = ec._ChangedFile_ChangeType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var changedFilesImplementors = []string{"ChangedFiles"}

func (ec *executionContext) _ChangedFiles(ctx context.Context, sel ast.SelectionSet, obj *models.ChangedFiles) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, changedFilesImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChangedFiles")
		case "Added":
			out.Values[i] = ec._ChangedFiles_Added(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Modified":
			out.Values[i] = ec._ChangedFiles_Modified(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Deleted":
			out.Values[i] = ec._ChangedFiles_Deleted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var commitImplementors = []string{"Commit"}

func (ec *executionContext) _Commit(ctx context.Context, sel ast.SelectionSet, obj *models.Commit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, commitImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Commit")
		case "Id":
			out.Values[i] = ec._Commit_Id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "PrecedingCommits":
			out.Values[i] = ec._Commit_PrecedingCommits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "AuthorName":
			out.Values[i] = ec._Commit_AuthorName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "AuthorEmail":
			out.Values[i] = ec._Commit_AuthorEmail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "AuthorDate":
			out.Values[i] = ec._Commit_AuthorDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CommitterName":
			out.Values[i] = ec._Commit_CommitterName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CommitterEmail":
			out.Values[i] = ec._Commit_CommitterEmail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CommitterDate":
			out.Values[i] = ec._Commit_CommitterDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Message":
			out.Values[i] = ec._Commit_Message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ChangedFiles":
			out.Values[i] = ec._Commit_ChangedFiles(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ChangedPackages":
			out.Values[i] = ec._Commit_ChangedPackages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ChangedVersions":
			out.Values[i] = ec._Commit_ChangedVersions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "KeywordChanges":
			out.Values[i] = ec._Commit_KeywordChanges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gitHubPullRequestFileNodeImplementors = []string{"GitHubPullRequestFileNode"}

func (ec *executionContext) _GitHubPullRequestFileNode(ctx context.Context, sel ast.SelectionSet, obj *models.GitHubPullRequestFileNode) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gitHubPullRequestFileNodeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GitHubPullRequestFileNode")
		case "Path":
			out.Values[i] = ec._GitHubPullRequestFileNode_Path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Additions":
			out.Values[i] = ec._GitHubPullRequestFileNode_Additions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Deletions":
			out.Values[i] = ec._GitHubPullRequestFileNode_Deletions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gitHubPullRequestLabelNodeImplementors = []string{"GitHubPullRequestLabelNode"}

func (ec *executionContext) _GitHubPullRequestLabelNode(ctx context.Context, sel ast.SelectionSet, obj *models.GitHubPullRequestLabelNode) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gitHubPullRequestLabelNodeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GitHubPullRequestLabelNode")
		case "Name":
			out.Values[i] = ec._GitHubPullRequestLabelNode_Name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Color":
			out.Values[i] = ec._GitHubPullRequestLabelNode_Color(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubPullRequestImplementors = []string{"GithubPullRequest"}

func (ec *executionContext) _GithubPullRequest(ctx context.Context, sel ast.SelectionSet, obj *models.GithubPullRequest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubPullRequestImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubPullRequest")
		case "Id":
			out.Values[i] = ec._GithubPullRequest_Id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Closed":
			out.Values[i] = ec._GithubPullRequest_Closed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Url":
			out.Values[i] = ec._GithubPullRequest_Url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Title":
			out.Values[i] = ec._GithubPullRequest_Title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CreatedAt":
			out.Values[i] = ec._GithubPullRequest_CreatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "UpdatedAt":
			out.Values[i] = ec._GithubPullRequest_UpdatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CiState":
			out.Values[i] = ec._GithubPullRequest_CiState(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CiStateLink":
			out.Values[i] = ec._GithubPullRequest_CiStateLink(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Labels":
			out.Values[i] = ec._GithubPullRequest_Labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Comments":
			out.Values[i] = ec._GithubPullRequest_Comments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Files":
			out.Values[i] = ec._GithubPullRequest_Files(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Author":
			out.Values[i] = ec._GithubPullRequest_Author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var keywordChangeImplementors = []string{"KeywordChange"}

func (ec *executionContext) _KeywordChange(ctx context.Context, sel ast.SelectionSet, obj *models.KeywordChange) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, keywordChangeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KeywordChange")
		case "Id":
			out.Values[i] = ec._KeywordChange_Id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CommitId":
			out.Values[i] = ec._KeywordChange_CommitId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Commit":
			out.Values[i] = ec._KeywordChange_Commit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "VersionId":
			out.Values[i] = ec._KeywordChange_VersionId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Version":
			out.Values[i] = ec._KeywordChange_Version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "PackageId":
			out.Values[i] = ec._KeywordChange_PackageId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Package":
			out.Values[i] = ec._KeywordChange_Package(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Added":
			out.Values[i] = ec._KeywordChange_Added(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Stabilized":
			out.Values[i] = ec._KeywordChange_Stabilized(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "All":
			out.Values[i] = ec._KeywordChange_All(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var maintainerImplementors = []string{"Maintainer"}

func (ec *executionContext) _Maintainer(ctx context.Context, sel ast.SelectionSet, obj *models.Maintainer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, maintainerImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Maintainer")
		case "Name":
			out.Values[i] = ec._Maintainer_Name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Email":
			out.Values[i] = ec._Maintainer_Email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Type":
			out.Values[i] = ec._Maintainer_Type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Restrict":
			out.Values[i] = ec._Maintainer_Restrict(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var maskImplementors = []string{"Mask"}

func (ec *executionContext) _Mask(ctx context.Context, sel ast.SelectionSet, obj *models.Mask) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, maskImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mask")
		case "Versions":
			out.Values[i] = ec._Mask_Versions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Author":
			out.Values[i] = ec._Mask_Author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "AuthorEmail":
			out.Values[i] = ec._Mask_AuthorEmail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Date":
			out.Values[i] = ec._Mask_Date(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Reason":
			out.Values[i] = ec._Mask_Reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var outdatedPackageImplementors = []string{"OutdatedPackage"}

func (ec *executionContext) _OutdatedPackage(ctx context.Context, sel ast.SelectionSet, obj *models.OutdatedPackages) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, outdatedPackageImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OutdatedPackage")
		case "Atom":
			out.Values[i] = ec._OutdatedPackage_Atom(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "GentooVersion":
			out.Values[i] = ec._OutdatedPackage_GentooVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "NewestVersion":
			out.Values[i] = ec._OutdatedPackage_NewestVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var packageImplementors = []string{"Package"}

func (ec *executionContext) _Package(ctx context.Context, sel ast.SelectionSet, obj *models.Package) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, packageImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Package")
		case "Atom":
			out.Values[i] = ec._Package_Atom(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Category":
			out.Values[i] = ec._Package_Category(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Name":
			out.Values[i] = ec._Package_Name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Versions":
			out.Values[i] = ec._Package_Versions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Longdescription":
			out.Values[i] = ec._Package_Longdescription(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Maintainers":
			out.Values[i] = ec._Package_Maintainers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Commits":
			out.Values[i] = ec._Package_Commits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "PrecedingCommits":
			out.Values[i] = ec._Package_PrecedingCommits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "PkgCheckResults":
			out.Values[i] = ec._Package_PkgCheckResults(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Outdated":
			out.Values[i] = ec._Package_Outdated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Bugs":
			out.Values[i] = ec._Package_Bugs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "PullRequests":
			out.Values[i] = ec._Package_PullRequests(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ReverseDependencies":
			out.Values[i] = ec._Package_ReverseDependencies(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pkgCheckResultImplementors = []string{"PkgCheckResult"}

func (ec *executionContext) _PkgCheckResult(ctx context.Context, sel ast.SelectionSet, obj *models.PkgCheckResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pkgCheckResultImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PkgCheckResult")
		case "Atom":
			out.Values[i] = ec._PkgCheckResult_Atom(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Category":
			out.Values[i] = ec._PkgCheckResult_Category(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Package":
			out.Values[i] = ec._PkgCheckResult_Package(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Version":
			out.Values[i] = ec._PkgCheckResult_Version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CPV":
			out.Values[i] = ec._PkgCheckResult_CPV(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Class":
			out.Values[i] = ec._PkgCheckResult_Class(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Message":
			out.Values[i] = ec._PkgCheckResult_Message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "category":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_category(ctx, field)
				return res
			})
		case "categories":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_categories(ctx, field)
				return res
			})
		case "commit":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_commit(ctx, field)
				return res
			})
		case "commits":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_commits(ctx, field)
				return res
			})
		case "mask":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_mask(ctx, field)
				return res
			})
		case "masks":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_masks(ctx, field)
				return res
			})
		case "outdatedPackage":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_outdatedPackage(ctx, field)
				return res
			})
		case "outdatedPackages":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_outdatedPackages(ctx, field)
				return res
			})
		case "pkgCheckResult":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_pkgCheckResult(ctx, field)
				return res
			})
		case "pkgCheckResults":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_pkgCheckResults(ctx, field)
				return res
			})
		case "package":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_package(ctx, field)
				return res
			})
		case "packages":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_packages(ctx, field)
				return res
			})
		case "packageSearch":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_packageSearch(ctx, field)
				return res
			})
		case "useflag":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_useflag(ctx, field)
				return res
			})
		case "useflags":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_useflags(ctx, field)
				return res
			})
		case "version":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_version(ctx, field)
				return res
			})
		case "versions":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_versions(ctx, field)
				return res
			})
		case "application":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_application(ctx, field)
				return res
			})
		case "lastCommitTime":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_lastCommitTime(ctx, field)
				return res
			})
		case "addedPackages":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_addedPackages(ctx, field)
				return res
			})
		case "updatedVersions":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_updatedVersions(ctx, field)
				return res
			})
		case "stabilizedVersions":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_stabilizedVersions(ctx, field)
				return res
			})
		case "keywordedVersions":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_keywordedVersions(ctx, field)
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var reverseDependencyImplementors = []string{"ReverseDependency"}

func (ec *executionContext) _ReverseDependency(ctx context.Context, sel ast.SelectionSet, obj *models.ReverseDependency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, reverseDependencyImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ReverseDependency")
		case "Id":
			out.Values[i] = ec._ReverseDependency_Id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Atom":
			out.Values[i] = ec._ReverseDependency_Atom(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Type":
			out.Values[i] = ec._ReverseDependency_Type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ReverseDependencyAtom":
			out.Values[i] = ec._ReverseDependency_ReverseDependencyAtom(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ReverseDependencyVersion":
			out.Values[i] = ec._ReverseDependency_ReverseDependencyVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Condition":
			out.Values[i] = ec._ReverseDependency_Condition(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var useflagImplementors = []string{"Useflag"}

func (ec *executionContext) _Useflag(ctx context.Context, sel ast.SelectionSet, obj *models.Useflag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, useflagImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Useflag")
		case "Id":
			out.Values[i] = ec._Useflag_Id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Name":
			out.Values[i] = ec._Useflag_Name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Scope":
			out.Values[i] = ec._Useflag_Scope(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Description":
			out.Values[i] = ec._Useflag_Description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "UseExpand":
			out.Values[i] = ec._Useflag_UseExpand(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Package":
			out.Values[i] = ec._Useflag_Package(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var versionImplementors = []string{"Version"}

func (ec *executionContext) _Version(ctx context.Context, sel ast.SelectionSet, obj *models.Version) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Version")
		case "Id":
			out.Values[i] = ec._Version_Id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Category":
			out.Values[i] = ec._Version_Category(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Package":
			out.Values[i] = ec._Version_Package(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Atom":
			out.Values[i] = ec._Version_Atom(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Version":
			out.Values[i] = ec._Version_Version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Slot":
			out.Values[i] = ec._Version_Slot(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Subslot":
			out.Values[i] = ec._Version_Subslot(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "EAPI":
			out.Values[i] = ec._Version_EAPI(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Keywords":
			out.Values[i] = ec._Version_Keywords(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Useflags":
			out.Values[i] = ec._Version_Useflags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Restricts":
			out.Values[i] = ec._Version_Restricts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Properties":
			out.Values[i] = ec._Version_Properties(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Homepage":
			out.Values[i] = ec._Version_Homepage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "License":
			out.Values[i] = ec._Version_License(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Description":
			out.Values[i] = ec._Version_Description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Commits":
			out.Values[i] = ec._Version_Commits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Masks":
			out.Values[i] = ec._Version_Masks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "PkgCheckResults":
			out.Values[i] = ec._Version_PkgCheckResults(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Dependencies":
			out.Values[i] = ec._Version_Dependencies(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNBug2sokoᚋpkgᚋmodelsᚐBug(ctx context.Context, sel ast.SelectionSet, v models.Bug) graphql.Marshaler {
	return ec._Bug(ctx, sel, &v)
}

func (ec *executionContext) marshalNBug2ᚕᚖsokoᚋpkgᚋmodelsᚐBugᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Bug) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBug2ᚖsokoᚋpkgᚋmodelsᚐBug(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNBug2ᚖsokoᚋpkgᚋmodelsᚐBug(ctx context.Context, sel ast.SelectionSet, v *models.Bug) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Bug(ctx, sel, v)
}

func (ec *executionContext) marshalNChangedFile2sokoᚋpkgᚋmodelsᚐChangedFile(ctx context.Context, sel ast.SelectionSet, v models.ChangedFile) graphql.Marshaler {
	return ec._ChangedFile(ctx, sel, &v)
}

func (ec *executionContext) marshalNChangedFile2ᚕᚖsokoᚋpkgᚋmodelsᚐChangedFileᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.ChangedFile) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChangedFile2ᚖsokoᚋpkgᚋmodelsᚐChangedFile(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNChangedFile2ᚖsokoᚋpkgᚋmodelsᚐChangedFile(ctx context.Context, sel ast.SelectionSet, v *models.ChangedFile) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ChangedFile(ctx, sel, v)
}

func (ec *executionContext) marshalNChangedFiles2sokoᚋpkgᚋmodelsᚐChangedFiles(ctx context.Context, sel ast.SelectionSet, v models.ChangedFiles) graphql.Marshaler {
	return ec._ChangedFiles(ctx, sel, &v)
}

func (ec *executionContext) marshalNChangedFiles2ᚖsokoᚋpkgᚋmodelsᚐChangedFiles(ctx context.Context, sel ast.SelectionSet, v *models.ChangedFiles) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ChangedFiles(ctx, sel, v)
}

func (ec *executionContext) marshalNCommit2sokoᚋpkgᚋmodelsᚐCommit(ctx context.Context, sel ast.SelectionSet, v models.Commit) graphql.Marshaler {
	return ec._Commit(ctx, sel, &v)
}

func (ec *executionContext) marshalNCommit2ᚕᚖsokoᚋpkgᚋmodelsᚐCommitᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Commit) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCommit2ᚖsokoᚋpkgᚋmodelsᚐCommit(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNCommit2ᚖsokoᚋpkgᚋmodelsᚐCommit(ctx context.Context, sel ast.SelectionSet, v *models.Commit) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Commit(ctx, sel, v)
}

func (ec *executionContext) marshalNGitHubPullRequestFileNode2sokoᚋpkgᚋmodelsᚐGitHubPullRequestFileNode(ctx context.Context, sel ast.SelectionSet, v models.GitHubPullRequestFileNode) graphql.Marshaler {
	return ec._GitHubPullRequestFileNode(ctx, sel, &v)
}

func (ec *executionContext) marshalNGitHubPullRequestFileNode2ᚕsokoᚋpkgᚋmodelsᚐGitHubPullRequestFileNodeᚄ(ctx context.Context, sel ast.SelectionSet, v []models.GitHubPullRequestFileNode) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGitHubPullRequestFileNode2sokoᚋpkgᚋmodelsᚐGitHubPullRequestFileNode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNGitHubPullRequestLabelNode2sokoᚋpkgᚋmodelsᚐGitHubPullRequestLabelNode(ctx context.Context, sel ast.SelectionSet, v models.GitHubPullRequestLabelNode) graphql.Marshaler {
	return ec._GitHubPullRequestLabelNode(ctx, sel, &v)
}

func (ec *executionContext) marshalNGitHubPullRequestLabelNode2ᚕsokoᚋpkgᚋmodelsᚐGitHubPullRequestLabelNodeᚄ(ctx context.Context, sel ast.SelectionSet, v []models.GitHubPullRequestLabelNode) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGitHubPullRequestLabelNode2sokoᚋpkgᚋmodelsᚐGitHubPullRequestLabelNode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNGithubPullRequest2sokoᚋpkgᚋmodelsᚐGithubPullRequest(ctx context.Context, sel ast.SelectionSet, v models.GithubPullRequest) graphql.Marshaler {
	return ec._GithubPullRequest(ctx, sel, &v)
}

func (ec *executionContext) marshalNGithubPullRequest2ᚕᚖsokoᚋpkgᚋmodelsᚐGithubPullRequestᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.GithubPullRequest) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGithubPullRequest2ᚖsokoᚋpkgᚋmodelsᚐGithubPullRequest(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNGithubPullRequest2ᚖsokoᚋpkgᚋmodelsᚐGithubPullRequest(ctx context.Context, sel ast.SelectionSet, v *models.GithubPullRequest) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._GithubPullRequest(ctx, sel, v)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNKeywordChange2sokoᚋpkgᚋmodelsᚐKeywordChange(ctx context.Context, sel ast.SelectionSet, v models.KeywordChange) graphql.Marshaler {
	return ec._KeywordChange(ctx, sel, &v)
}

func (ec *executionContext) marshalNKeywordChange2ᚕᚖsokoᚋpkgᚋmodelsᚐKeywordChangeᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.KeywordChange) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNKeywordChange2ᚖsokoᚋpkgᚋmodelsᚐKeywordChange(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNKeywordChange2ᚖsokoᚋpkgᚋmodelsᚐKeywordChange(ctx context.Context, sel ast.SelectionSet, v *models.KeywordChange) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._KeywordChange(ctx, sel, v)
}

func (ec *executionContext) marshalNMaintainer2sokoᚋpkgᚋmodelsᚐMaintainer(ctx context.Context, sel ast.SelectionSet, v models.Maintainer) graphql.Marshaler {
	return ec._Maintainer(ctx, sel, &v)
}

func (ec *executionContext) marshalNMaintainer2ᚕᚖsokoᚋpkgᚋmodelsᚐMaintainerᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Maintainer) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMaintainer2ᚖsokoᚋpkgᚋmodelsᚐMaintainer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNMaintainer2ᚖsokoᚋpkgᚋmodelsᚐMaintainer(ctx context.Context, sel ast.SelectionSet, v *models.Maintainer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Maintainer(ctx, sel, v)
}

func (ec *executionContext) marshalNMask2sokoᚋpkgᚋmodelsᚐMask(ctx context.Context, sel ast.SelectionSet, v models.Mask) graphql.Marshaler {
	return ec._Mask(ctx, sel, &v)
}

func (ec *executionContext) marshalNMask2ᚕᚖsokoᚋpkgᚋmodelsᚐMaskᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Mask) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMask2ᚖsokoᚋpkgᚋmodelsᚐMask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNMask2ᚖsokoᚋpkgᚋmodelsᚐMask(ctx context.Context, sel ast.SelectionSet, v *models.Mask) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Mask(ctx, sel, v)
}

func (ec *executionContext) marshalNOutdatedPackage2sokoᚋpkgᚋmodelsᚐOutdatedPackages(ctx context.Context, sel ast.SelectionSet, v models.OutdatedPackages) graphql.Marshaler {
	return ec._OutdatedPackage(ctx, sel, &v)
}

func (ec *executionContext) marshalNOutdatedPackage2ᚕᚖsokoᚋpkgᚋmodelsᚐOutdatedPackagesᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.OutdatedPackages) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOutdatedPackage2ᚖsokoᚋpkgᚋmodelsᚐOutdatedPackages(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNOutdatedPackage2ᚖsokoᚋpkgᚋmodelsᚐOutdatedPackages(ctx context.Context, sel ast.SelectionSet, v *models.OutdatedPackages) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._OutdatedPackage(ctx, sel, v)
}

func (ec *executionContext) marshalNPackage2sokoᚋpkgᚋmodelsᚐPackage(ctx context.Context, sel ast.SelectionSet, v models.Package) graphql.Marshaler {
	return ec._Package(ctx, sel, &v)
}

func (ec *executionContext) marshalNPackage2ᚕᚖsokoᚋpkgᚋmodelsᚐPackageᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Package) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPackage2ᚖsokoᚋpkgᚋmodelsᚐPackage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNPackage2ᚖsokoᚋpkgᚋmodelsᚐPackage(ctx context.Context, sel ast.SelectionSet, v *models.Package) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Package(ctx, sel, v)
}

func (ec *executionContext) marshalNPkgCheckResult2sokoᚋpkgᚋmodelsᚐPkgCheckResult(ctx context.Context, sel ast.SelectionSet, v models.PkgCheckResult) graphql.Marshaler {
	return ec._PkgCheckResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNPkgCheckResult2ᚕᚖsokoᚋpkgᚋmodelsᚐPkgCheckResultᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.PkgCheckResult) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPkgCheckResult2ᚖsokoᚋpkgᚋmodelsᚐPkgCheckResult(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNPkgCheckResult2ᚖsokoᚋpkgᚋmodelsᚐPkgCheckResult(ctx context.Context, sel ast.SelectionSet, v *models.PkgCheckResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PkgCheckResult(ctx, sel, v)
}

func (ec *executionContext) marshalNReverseDependency2sokoᚋpkgᚋmodelsᚐReverseDependency(ctx context.Context, sel ast.SelectionSet, v models.ReverseDependency) graphql.Marshaler {
	return ec._ReverseDependency(ctx, sel, &v)
}

func (ec *executionContext) marshalNReverseDependency2ᚕᚖsokoᚋpkgᚋmodelsᚐReverseDependencyᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.ReverseDependency) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNReverseDependency2ᚖsokoᚋpkgᚋmodelsᚐReverseDependency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNReverseDependency2ᚖsokoᚋpkgᚋmodelsᚐReverseDependency(ctx context.Context, sel ast.SelectionSet, v *models.ReverseDependency) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ReverseDependency(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	return graphql.UnmarshalTime(v)
}

func (ec *executionContext) marshalNTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNVersion2sokoᚋpkgᚋmodelsᚐVersion(ctx context.Context, sel ast.SelectionSet, v models.Version) graphql.Marshaler {
	return ec._Version(ctx, sel, &v)
}

func (ec *executionContext) marshalNVersion2ᚕᚖsokoᚋpkgᚋmodelsᚐVersionᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Version) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVersion2ᚖsokoᚋpkgᚋmodelsᚐVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNVersion2ᚖsokoᚋpkgᚋmodelsᚐVersion(ctx context.Context, sel ast.SelectionSet, v *models.Version) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Version(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalOApplication2sokoᚋpkgᚋmodelsᚐApplication(ctx context.Context, sel ast.SelectionSet, v models.Application) graphql.Marshaler {
	return ec._Application(ctx, sel, &v)
}

func (ec *executionContext) marshalOApplication2ᚖsokoᚋpkgᚋmodelsᚐApplication(ctx context.Context, sel ast.SelectionSet, v *models.Application) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Application(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBoolean2bool(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOBoolean2bool(ctx, sel, *v)
}

func (ec *executionContext) marshalOCategory2sokoᚋpkgᚋmodelsᚐCategory(ctx context.Context, sel ast.SelectionSet, v models.Category) graphql.Marshaler {
	return ec._Category(ctx, sel, &v)
}

func (ec *executionContext) marshalOCategory2ᚕᚖsokoᚋpkgᚋmodelsᚐCategory(ctx context.Context, sel ast.SelectionSet, v []*models.Category) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCategory2ᚖsokoᚋpkgᚋmodelsᚐCategory(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOCategory2ᚖsokoᚋpkgᚋmodelsᚐCategory(ctx context.Context, sel ast.SelectionSet, v *models.Category) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Category(ctx, sel, v)
}

func (ec *executionContext) marshalOCommit2sokoᚋpkgᚋmodelsᚐCommit(ctx context.Context, sel ast.SelectionSet, v models.Commit) graphql.Marshaler {
	return ec._Commit(ctx, sel, &v)
}

func (ec *executionContext) marshalOCommit2ᚕᚖsokoᚋpkgᚋmodelsᚐCommit(ctx context.Context, sel ast.SelectionSet, v []*models.Commit) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCommit2ᚖsokoᚋpkgᚋmodelsᚐCommit(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOCommit2ᚖsokoᚋpkgᚋmodelsᚐCommit(ctx context.Context, sel ast.SelectionSet, v *models.Commit) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Commit(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInt2int(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOInt2int(ctx, sel, *v)
}

func (ec *executionContext) marshalOMask2sokoᚋpkgᚋmodelsᚐMask(ctx context.Context, sel ast.SelectionSet, v models.Mask) graphql.Marshaler {
	return ec._Mask(ctx, sel, &v)
}

func (ec *executionContext) marshalOMask2ᚕᚖsokoᚋpkgᚋmodelsᚐMask(ctx context.Context, sel ast.SelectionSet, v []*models.Mask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMask2ᚖsokoᚋpkgᚋmodelsᚐMask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOMask2ᚖsokoᚋpkgᚋmodelsᚐMask(ctx context.Context, sel ast.SelectionSet, v *models.Mask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Mask(ctx, sel, v)
}

func (ec *executionContext) marshalOOutdatedPackage2sokoᚋpkgᚋmodelsᚐOutdatedPackages(ctx context.Context, sel ast.SelectionSet, v models.OutdatedPackages) graphql.Marshaler {
	return ec._OutdatedPackage(ctx, sel, &v)
}

func (ec *executionContext) marshalOOutdatedPackage2ᚕᚖsokoᚋpkgᚋmodelsᚐOutdatedPackages(ctx context.Context, sel ast.SelectionSet, v []*models.OutdatedPackages) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOOutdatedPackage2ᚖsokoᚋpkgᚋmodelsᚐOutdatedPackages(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOOutdatedPackage2ᚖsokoᚋpkgᚋmodelsᚐOutdatedPackages(ctx context.Context, sel ast.SelectionSet, v *models.OutdatedPackages) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OutdatedPackage(ctx, sel, v)
}

func (ec *executionContext) marshalOPackage2sokoᚋpkgᚋmodelsᚐPackage(ctx context.Context, sel ast.SelectionSet, v models.Package) graphql.Marshaler {
	return ec._Package(ctx, sel, &v)
}

func (ec *executionContext) marshalOPackage2ᚕᚖsokoᚋpkgᚋmodelsᚐPackage(ctx context.Context, sel ast.SelectionSet, v []*models.Package) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPackage2ᚖsokoᚋpkgᚋmodelsᚐPackage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOPackage2ᚖsokoᚋpkgᚋmodelsᚐPackage(ctx context.Context, sel ast.SelectionSet, v *models.Package) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Package(ctx, sel, v)
}

func (ec *executionContext) marshalOPkgCheckResult2sokoᚋpkgᚋmodelsᚐPkgCheckResult(ctx context.Context, sel ast.SelectionSet, v models.PkgCheckResult) graphql.Marshaler {
	return ec._PkgCheckResult(ctx, sel, &v)
}

func (ec *executionContext) marshalOPkgCheckResult2ᚕᚖsokoᚋpkgᚋmodelsᚐPkgCheckResult(ctx context.Context, sel ast.SelectionSet, v []*models.PkgCheckResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPkgCheckResult2ᚖsokoᚋpkgᚋmodelsᚐPkgCheckResult(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOPkgCheckResult2ᚖsokoᚋpkgᚋmodelsᚐPkgCheckResult(ctx context.Context, sel ast.SelectionSet, v *models.PkgCheckResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PkgCheckResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOString2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	return graphql.UnmarshalTime(v)
}

func (ec *executionContext) marshalOTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	return graphql.MarshalTime(v)
}

func (ec *executionContext) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOTime2timeᚐTime(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOTime2timeᚐTime(ctx, sel, *v)
}

func (ec *executionContext) marshalOUseflag2sokoᚋpkgᚋmodelsᚐUseflag(ctx context.Context, sel ast.SelectionSet, v models.Useflag) graphql.Marshaler {
	return ec._Useflag(ctx, sel, &v)
}

func (ec *executionContext) marshalOUseflag2ᚕᚖsokoᚋpkgᚋmodelsᚐUseflag(ctx context.Context, sel ast.SelectionSet, v []*models.Useflag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUseflag2ᚖsokoᚋpkgᚋmodelsᚐUseflag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOUseflag2ᚖsokoᚋpkgᚋmodelsᚐUseflag(ctx context.Context, sel ast.SelectionSet, v *models.Useflag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Useflag(ctx, sel, v)
}

func (ec *executionContext) marshalOVersion2sokoᚋpkgᚋmodelsᚐVersion(ctx context.Context, sel ast.SelectionSet, v models.Version) graphql.Marshaler {
	return ec._Version(ctx, sel, &v)
}

func (ec *executionContext) marshalOVersion2ᚕᚖsokoᚋpkgᚋmodelsᚐVersion(ctx context.Context, sel ast.SelectionSet, v []*models.Version) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOVersion2ᚖsokoᚋpkgᚋmodelsᚐVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOVersion2ᚖsokoᚋpkgᚋmodelsᚐVersion(ctx context.Context, sel ast.SelectionSet, v *models.Version) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Version(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v introspection.Schema) graphql.Marshaler {
	return ec.___Schema(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
